// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.4
// source: battleenemy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import { THeroAttr } from './battleplayer.ts'

export const protobufPackage = 'battleenemy'

export interface TBattleEnemyFleet {
    FleetId?: number | undefined
    State?: number | undefined
    Ships: TBattleEnemyShip[]
}

export interface TBattleEnemyShip {
    ShipId?: number | undefined
    Attr: THeroAttr[]
    PSkill: number[]
}

function createBaseTBattleEnemyFleet(): TBattleEnemyFleet {
    return { FleetId: 0, State: 0, Ships: [] }
}

export const TBattleEnemyFleet: MessageFns<TBattleEnemyFleet> = {
    encode(message: TBattleEnemyFleet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.FleetId !== undefined && message.FleetId !== 0) {
            writer.uint32(8).int32(message.FleetId)
        }
        if (message.State !== undefined && message.State !== 0) {
            writer.uint32(16).int32(message.State)
        }
        for (const v of message.Ships) {
            TBattleEnemyShip.encode(v!, writer.uint32(26).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleEnemyFleet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleEnemyFleet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.FleetId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.State = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 26) {
                        break
                    }

                    message.Ships.push(TBattleEnemyShip.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleEnemyFleet {
        return {
            FleetId: isSet(object.FleetId) ? globalThis.Number(object.FleetId) : 0,
            State: isSet(object.State) ? globalThis.Number(object.State) : 0,
            Ships: globalThis.Array.isArray(object?.Ships)
                ? object.Ships.map((e: any) => TBattleEnemyShip.fromJSON(e))
                : []
        }
    },

    toJSON(message: TBattleEnemyFleet): unknown {
        const obj: any = {}
        if (message.FleetId !== undefined && message.FleetId !== 0) {
            obj.FleetId = Math.round(message.FleetId)
        }
        if (message.State !== undefined && message.State !== 0) {
            obj.State = Math.round(message.State)
        }
        if (message.Ships?.length) {
            obj.Ships = message.Ships.map((e) => TBattleEnemyShip.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleEnemyFleet>, I>>(base?: I): TBattleEnemyFleet {
        return TBattleEnemyFleet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleEnemyFleet>, I>>(object: I): TBattleEnemyFleet {
        const message = createBaseTBattleEnemyFleet()
        message.FleetId = object.FleetId ?? 0
        message.State = object.State ?? 0
        message.Ships = object.Ships?.map((e) => TBattleEnemyShip.fromPartial(e)) || []
        return message
    }
}

function createBaseTBattleEnemyShip(): TBattleEnemyShip {
    return { ShipId: 0, Attr: [], PSkill: [] }
}

export const TBattleEnemyShip: MessageFns<TBattleEnemyShip> = {
    encode(message: TBattleEnemyShip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.ShipId !== undefined && message.ShipId !== 0) {
            writer.uint32(8).int32(message.ShipId)
        }
        for (const v of message.Attr) {
            THeroAttr.encode(v!, writer.uint32(18).fork()).join()
        }
        for (const v of message.PSkill) {
            writer.uint32(24).int32(v!)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleEnemyShip {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleEnemyShip()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.ShipId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.Attr.push(THeroAttr.decode(reader, reader.uint32()))
                    continue
                }
                case 3: {
                    if (tag === 24) {
                        message.PSkill.push(reader.int32())

                        continue
                    }

                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.PSkill.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleEnemyShip {
        return {
            ShipId: isSet(object.ShipId) ? globalThis.Number(object.ShipId) : 0,
            Attr: globalThis.Array.isArray(object?.Attr)
                ? object.Attr.map((e: any) => THeroAttr.fromJSON(e))
                : [],
            PSkill: globalThis.Array.isArray(object?.PSkill)
                ? object.PSkill.map((e: any) => globalThis.Number(e))
                : []
        }
    },

    toJSON(message: TBattleEnemyShip): unknown {
        const obj: any = {}
        if (message.ShipId !== undefined && message.ShipId !== 0) {
            obj.ShipId = Math.round(message.ShipId)
        }
        if (message.Attr?.length) {
            obj.Attr = message.Attr.map((e) => THeroAttr.toJSON(e))
        }
        if (message.PSkill?.length) {
            obj.PSkill = message.PSkill.map((e) => Math.round(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleEnemyShip>, I>>(base?: I): TBattleEnemyShip {
        return TBattleEnemyShip.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleEnemyShip>, I>>(object: I): TBattleEnemyShip {
        const message = createBaseTBattleEnemyShip()
        message.ShipId = object.ShipId ?? 0
        message.Attr = object.Attr?.map((e) => THeroAttr.fromPartial(e)) || []
        message.PSkill = object.PSkill?.map((e) => e) || []
        return message
    }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin ? T
    : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
    : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin ? P
    :
        & P
        & { [K in keyof P]: Exact<P[K], I[K]> }
        & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function isSet(value: any): boolean {
    return value !== null && value !== undefined
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter
    decode(input: BinaryReader | Uint8Array, length?: number): T
    fromJSON(object: any): T
    toJSON(message: T): unknown
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
