// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.4
// source: battleplayer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'

export const protobufPackage = 'battleplayer'

export interface TBattleEquip {
    EquipTid?: number | undefined
    EquipIndex?: number | undefined
    PlaneNum?: number | undefined
    AttrValue: THeroAttr[]
    PSkillEquipList: TEquipPSkills[]
    PetId?: number | undefined
}

export interface TBattleExtraParam {
    ArrHeroId: number[]
    StrategyId?: number | undefined
    NpcAssist?: boolean | undefined
    Uid?: number | undefined
    tacticType?: number | undefined
    fleetId?: number | undefined
    isMultiFleet?: boolean | undefined
    copyId?: number | undefined
}

export interface TBattleFleet {
    FleetId?: number | undefined
    FormationId?: number | undefined
    Index?: number | undefined
    Ships: TBattleShip[]
    StrategyId?: number | undefined
    ConditionList: number[]
    KillTimes?: number | undefined
    HeroList: number[]
    TacticType?: number | undefined
}

export interface TBattlePlayer {
    Pid?: number | undefined
    Uid?: number | undefined
    Uname?: string | undefined
    Level?: number | undefined
    PlayerCamp?: number | undefined
    Index?: number | undefined
    FleetInfo?: TBattleFleet | undefined
    OpenFunc: number[]
    BattleMode?: number | undefined
    RandomFactors: TRandomFactor[]
}

export interface TBattlePlayerList {
    BattlePlayerList: TBattlePlayer[]
}

export interface TBattleShip {
    HeroId?: number | undefined
    TemplateId?: number | undefined
    Level?: number | undefined
    Index?: number | undefined
    Attr: THeroAttr[]
    CurHp?: number | undefined
    Equips: TBattleEquip[]
    PSkill: TFiledPSkillLv[]
    BathBuff: number[]
    AdvEffectIdList: number[]
    EquipGridNum?: number | undefined
    Fashioning?: number | undefined
    HurtPer?: number | undefined
}

export interface TEquipPSkills {
    PSkillId?: number | undefined
    PSkillLv?: number | undefined
}

export interface TFiledPSkillLv {
    PSkillId?: number | undefined
    PSkillLv?: number | undefined
}

export interface THeroAttr {
    AttrId?: number | undefined
    AttrValue?: number | undefined
}

export interface TRandomFactor {
    Factors: number[]
    GroupId?: number | undefined
    SetId?: number | undefined
}

function createBaseTBattleEquip(): TBattleEquip {
    return {
        EquipTid: 0,
        EquipIndex: 0,
        PlaneNum: 0,
        AttrValue: [],
        PSkillEquipList: [],
        PetId: 0
    }
}

export const TBattleEquip: MessageFns<TBattleEquip> = {
    encode(message: TBattleEquip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.EquipTid !== undefined && message.EquipTid !== 0) {
            writer.uint32(8).int32(message.EquipTid)
        }
        if (message.EquipIndex !== undefined && message.EquipIndex !== 0) {
            writer.uint32(16).int32(message.EquipIndex)
        }
        if (message.PlaneNum !== undefined && message.PlaneNum !== 0) {
            writer.uint32(24).int32(message.PlaneNum)
        }
        for (const v of message.AttrValue) {
            THeroAttr.encode(v!, writer.uint32(34).fork()).join()
        }
        for (const v of message.PSkillEquipList) {
            TEquipPSkills.encode(v!, writer.uint32(42).fork()).join()
        }
        if (message.PetId !== undefined && message.PetId !== 0) {
            writer.uint32(48).int32(message.PetId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleEquip {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleEquip()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.EquipTid = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.EquipIndex = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.PlaneNum = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 34) {
                        break
                    }

                    message.AttrValue.push(THeroAttr.decode(reader, reader.uint32()))
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.PSkillEquipList.push(TEquipPSkills.decode(reader, reader.uint32()))
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.PetId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleEquip {
        return {
            EquipTid: isSet(object.EquipTid) ? globalThis.Number(object.EquipTid) : 0,
            EquipIndex: isSet(object.EquipIndex) ? globalThis.Number(object.EquipIndex) : 0,
            PlaneNum: isSet(object.PlaneNum) ? globalThis.Number(object.PlaneNum) : 0,
            AttrValue: globalThis.Array.isArray(object?.AttrValue)
                ? object.AttrValue.map((e: any) => THeroAttr.fromJSON(e))
                : [],
            PSkillEquipList: globalThis.Array.isArray(object?.PSkillEquipList)
                ? object.PSkillEquipList.map((e: any) => TEquipPSkills.fromJSON(e))
                : [],
            PetId: isSet(object.PetId) ? globalThis.Number(object.PetId) : 0
        }
    },

    toJSON(message: TBattleEquip): unknown {
        const obj: any = {}
        if (message.EquipTid !== undefined && message.EquipTid !== 0) {
            obj.EquipTid = Math.round(message.EquipTid)
        }
        if (message.EquipIndex !== undefined && message.EquipIndex !== 0) {
            obj.EquipIndex = Math.round(message.EquipIndex)
        }
        if (message.PlaneNum !== undefined && message.PlaneNum !== 0) {
            obj.PlaneNum = Math.round(message.PlaneNum)
        }
        if (message.AttrValue?.length) {
            obj.AttrValue = message.AttrValue.map((e) => THeroAttr.toJSON(e))
        }
        if (message.PSkillEquipList?.length) {
            obj.PSkillEquipList = message.PSkillEquipList.map((e) => TEquipPSkills.toJSON(e))
        }
        if (message.PetId !== undefined && message.PetId !== 0) {
            obj.PetId = Math.round(message.PetId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleEquip>, I>>(base?: I): TBattleEquip {
        return TBattleEquip.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleEquip>, I>>(object: I): TBattleEquip {
        const message = createBaseTBattleEquip()
        message.EquipTid = object.EquipTid ?? 0
        message.EquipIndex = object.EquipIndex ?? 0
        message.PlaneNum = object.PlaneNum ?? 0
        message.AttrValue = object.AttrValue?.map((e) => THeroAttr.fromPartial(e)) || []
        message.PSkillEquipList =
            object.PSkillEquipList?.map((e) => TEquipPSkills.fromPartial(e)) || []
        message.PetId = object.PetId ?? 0
        return message
    }
}

function createBaseTBattleExtraParam(): TBattleExtraParam {
    return {
        ArrHeroId: [],
        StrategyId: 0,
        NpcAssist: false,
        Uid: 0,
        tacticType: 0,
        fleetId: 0,
        isMultiFleet: false,
        copyId: 0
    }
}

export const TBattleExtraParam: MessageFns<TBattleExtraParam> = {
    encode(message: TBattleExtraParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.ArrHeroId) {
            writer.uint32(8).uint32(v!)
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            writer.uint32(16).int32(message.StrategyId)
        }
        if (message.NpcAssist !== undefined && message.NpcAssist !== false) {
            writer.uint32(24).bool(message.NpcAssist)
        }
        if (message.Uid !== undefined && message.Uid !== 0) {
            writer.uint32(32).uint64(message.Uid)
        }
        if (message.tacticType !== undefined && message.tacticType !== 0) {
            writer.uint32(40).int32(message.tacticType)
        }
        if (message.fleetId !== undefined && message.fleetId !== 0) {
            writer.uint32(48).int32(message.fleetId)
        }
        if (message.isMultiFleet !== undefined && message.isMultiFleet !== false) {
            writer.uint32(56).bool(message.isMultiFleet)
        }
        if (message.copyId !== undefined && message.copyId !== 0) {
            writer.uint32(64).int32(message.copyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleExtraParam {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleExtraParam()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.ArrHeroId.push(reader.uint32())

                        continue
                    }

                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.ArrHeroId.push(reader.uint32())
                        }

                        continue
                    }

                    break
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.StrategyId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.NpcAssist = reader.bool()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.Uid = longToNumber(reader.uint64())
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.tacticType = reader.int32()
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.fleetId = reader.int32()
                    continue
                }
                case 7: {
                    if (tag !== 56) {
                        break
                    }

                    message.isMultiFleet = reader.bool()
                    continue
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.copyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleExtraParam {
        return {
            ArrHeroId: globalThis.Array.isArray(object?.ArrHeroId)
                ? object.ArrHeroId.map((e: any) => globalThis.Number(e))
                : [],
            StrategyId: isSet(object.StrategyId) ? globalThis.Number(object.StrategyId) : 0,
            NpcAssist: isSet(object.NpcAssist) ? globalThis.Boolean(object.NpcAssist) : false,
            Uid: isSet(object.Uid) ? globalThis.Number(object.Uid) : 0,
            tacticType: isSet(object.tacticType) ? globalThis.Number(object.tacticType) : 0,
            fleetId: isSet(object.fleetId) ? globalThis.Number(object.fleetId) : 0,
            isMultiFleet: isSet(object.isMultiFleet)
                ? globalThis.Boolean(object.isMultiFleet)
                : false,
            copyId: isSet(object.copyId) ? globalThis.Number(object.copyId) : 0
        }
    },

    toJSON(message: TBattleExtraParam): unknown {
        const obj: any = {}
        if (message.ArrHeroId?.length) {
            obj.ArrHeroId = message.ArrHeroId.map((e) => Math.round(e))
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            obj.StrategyId = Math.round(message.StrategyId)
        }
        if (message.NpcAssist !== undefined && message.NpcAssist !== false) {
            obj.NpcAssist = message.NpcAssist
        }
        if (message.Uid !== undefined && message.Uid !== 0) {
            obj.Uid = Math.round(message.Uid)
        }
        if (message.tacticType !== undefined && message.tacticType !== 0) {
            obj.tacticType = Math.round(message.tacticType)
        }
        if (message.fleetId !== undefined && message.fleetId !== 0) {
            obj.fleetId = Math.round(message.fleetId)
        }
        if (message.isMultiFleet !== undefined && message.isMultiFleet !== false) {
            obj.isMultiFleet = message.isMultiFleet
        }
        if (message.copyId !== undefined && message.copyId !== 0) {
            obj.copyId = Math.round(message.copyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleExtraParam>, I>>(base?: I): TBattleExtraParam {
        return TBattleExtraParam.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleExtraParam>, I>>(object: I): TBattleExtraParam {
        const message = createBaseTBattleExtraParam()
        message.ArrHeroId = object.ArrHeroId?.map((e) => e) || []
        message.StrategyId = object.StrategyId ?? 0
        message.NpcAssist = object.NpcAssist ?? false
        message.Uid = object.Uid ?? 0
        message.tacticType = object.tacticType ?? 0
        message.fleetId = object.fleetId ?? 0
        message.isMultiFleet = object.isMultiFleet ?? false
        message.copyId = object.copyId ?? 0
        return message
    }
}

function createBaseTBattleFleet(): TBattleFleet {
    return {
        FleetId: 0,
        FormationId: 0,
        Index: 0,
        Ships: [],
        StrategyId: 0,
        ConditionList: [],
        KillTimes: 0,
        HeroList: [],
        TacticType: 0
    }
}

export const TBattleFleet: MessageFns<TBattleFleet> = {
    encode(message: TBattleFleet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.FleetId !== undefined && message.FleetId !== 0) {
            writer.uint32(8).int32(message.FleetId)
        }
        if (message.FormationId !== undefined && message.FormationId !== 0) {
            writer.uint32(16).int32(message.FormationId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(24).int32(message.Index)
        }
        for (const v of message.Ships) {
            TBattleShip.encode(v!, writer.uint32(34).fork()).join()
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            writer.uint32(40).int32(message.StrategyId)
        }
        for (const v of message.ConditionList) {
            writer.uint32(48).int32(v!)
        }
        if (message.KillTimes !== undefined && message.KillTimes !== 0) {
            writer.uint32(56).int32(message.KillTimes)
        }
        for (const v of message.HeroList) {
            writer.uint32(64).uint32(v!)
        }
        if (message.TacticType !== undefined && message.TacticType !== 0) {
            writer.uint32(72).int32(message.TacticType)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleFleet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleFleet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.FleetId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.FormationId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 34) {
                        break
                    }

                    message.Ships.push(TBattleShip.decode(reader, reader.uint32()))
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.StrategyId = reader.int32()
                    continue
                }
                case 6: {
                    if (tag === 48) {
                        message.ConditionList.push(reader.int32())

                        continue
                    }

                    if (tag === 50) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.ConditionList.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 7: {
                    if (tag !== 56) {
                        break
                    }

                    message.KillTimes = reader.int32()
                    continue
                }
                case 8: {
                    if (tag === 64) {
                        message.HeroList.push(reader.uint32())

                        continue
                    }

                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.HeroList.push(reader.uint32())
                        }

                        continue
                    }

                    break
                }
                case 9: {
                    if (tag !== 72) {
                        break
                    }

                    message.TacticType = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleFleet {
        return {
            FleetId: isSet(object.FleetId) ? globalThis.Number(object.FleetId) : 0,
            FormationId: isSet(object.FormationId) ? globalThis.Number(object.FormationId) : 0,
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            Ships: globalThis.Array.isArray(object?.Ships)
                ? object.Ships.map((e: any) => TBattleShip.fromJSON(e))
                : [],
            StrategyId: isSet(object.StrategyId) ? globalThis.Number(object.StrategyId) : 0,
            ConditionList: globalThis.Array.isArray(object?.ConditionList)
                ? object.ConditionList.map((e: any) => globalThis.Number(e))
                : [],
            KillTimes: isSet(object.KillTimes) ? globalThis.Number(object.KillTimes) : 0,
            HeroList: globalThis.Array.isArray(object?.HeroList)
                ? object.HeroList.map((e: any) => globalThis.Number(e))
                : [],
            TacticType: isSet(object.TacticType) ? globalThis.Number(object.TacticType) : 0
        }
    },

    toJSON(message: TBattleFleet): unknown {
        const obj: any = {}
        if (message.FleetId !== undefined && message.FleetId !== 0) {
            obj.FleetId = Math.round(message.FleetId)
        }
        if (message.FormationId !== undefined && message.FormationId !== 0) {
            obj.FormationId = Math.round(message.FormationId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.Ships?.length) {
            obj.Ships = message.Ships.map((e) => TBattleShip.toJSON(e))
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            obj.StrategyId = Math.round(message.StrategyId)
        }
        if (message.ConditionList?.length) {
            obj.ConditionList = message.ConditionList.map((e) => Math.round(e))
        }
        if (message.KillTimes !== undefined && message.KillTimes !== 0) {
            obj.KillTimes = Math.round(message.KillTimes)
        }
        if (message.HeroList?.length) {
            obj.HeroList = message.HeroList.map((e) => Math.round(e))
        }
        if (message.TacticType !== undefined && message.TacticType !== 0) {
            obj.TacticType = Math.round(message.TacticType)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleFleet>, I>>(base?: I): TBattleFleet {
        return TBattleFleet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleFleet>, I>>(object: I): TBattleFleet {
        const message = createBaseTBattleFleet()
        message.FleetId = object.FleetId ?? 0
        message.FormationId = object.FormationId ?? 0
        message.Index = object.Index ?? 0
        message.Ships = object.Ships?.map((e) => TBattleShip.fromPartial(e)) || []
        message.StrategyId = object.StrategyId ?? 0
        message.ConditionList = object.ConditionList?.map((e) => e) || []
        message.KillTimes = object.KillTimes ?? 0
        message.HeroList = object.HeroList?.map((e) => e) || []
        message.TacticType = object.TacticType ?? 0
        return message
    }
}

function createBaseTBattlePlayer(): TBattlePlayer {
    return {
        Pid: 0,
        Uid: 0,
        Uname: '',
        Level: 0,
        PlayerCamp: 0,
        Index: 0,
        FleetInfo: undefined,
        OpenFunc: [],
        BattleMode: 0,
        RandomFactors: []
    }
}

export const TBattlePlayer: MessageFns<TBattlePlayer> = {
    encode(message: TBattlePlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Pid !== undefined && message.Pid !== 0) {
            writer.uint32(8).uint32(message.Pid)
        }
        if (message.Uid !== undefined && message.Uid !== 0) {
            writer.uint32(16).uint64(message.Uid)
        }
        if (message.Uname !== undefined && message.Uname !== '') {
            writer.uint32(26).string(message.Uname)
        }
        if (message.Level !== undefined && message.Level !== 0) {
            writer.uint32(32).int32(message.Level)
        }
        if (message.PlayerCamp !== undefined && message.PlayerCamp !== 0) {
            writer.uint32(40).int32(message.PlayerCamp)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(48).int32(message.Index)
        }
        if (message.FleetInfo !== undefined) {
            TBattleFleet.encode(message.FleetInfo, writer.uint32(58).fork()).join()
        }
        for (const v of message.OpenFunc) {
            writer.uint32(64).int32(v!)
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            writer.uint32(72).int32(message.BattleMode)
        }
        for (const v of message.RandomFactors) {
            TRandomFactor.encode(v!, writer.uint32(82).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattlePlayer {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattlePlayer()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Pid = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Uid = longToNumber(reader.uint64())
                    continue
                }
                case 3: {
                    if (tag !== 26) {
                        break
                    }

                    message.Uname = reader.string()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.Level = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.PlayerCamp = reader.int32()
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 7: {
                    if (tag !== 58) {
                        break
                    }

                    message.FleetInfo = TBattleFleet.decode(reader, reader.uint32())
                    continue
                }
                case 8: {
                    if (tag === 64) {
                        message.OpenFunc.push(reader.int32())

                        continue
                    }

                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.OpenFunc.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 9: {
                    if (tag !== 72) {
                        break
                    }

                    message.BattleMode = reader.int32()
                    continue
                }
                case 10: {
                    if (tag !== 82) {
                        break
                    }

                    message.RandomFactors.push(TRandomFactor.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattlePlayer {
        return {
            Pid: isSet(object.Pid) ? globalThis.Number(object.Pid) : 0,
            Uid: isSet(object.Uid) ? globalThis.Number(object.Uid) : 0,
            Uname: isSet(object.Uname) ? globalThis.String(object.Uname) : '',
            Level: isSet(object.Level) ? globalThis.Number(object.Level) : 0,
            PlayerCamp: isSet(object.PlayerCamp) ? globalThis.Number(object.PlayerCamp) : 0,
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            FleetInfo: isSet(object.FleetInfo)
                ? TBattleFleet.fromJSON(object.FleetInfo)
                : undefined,
            OpenFunc: globalThis.Array.isArray(object?.OpenFunc)
                ? object.OpenFunc.map((e: any) => globalThis.Number(e))
                : [],
            BattleMode: isSet(object.BattleMode) ? globalThis.Number(object.BattleMode) : 0,
            RandomFactors: globalThis.Array.isArray(object?.RandomFactors)
                ? object.RandomFactors.map((e: any) => TRandomFactor.fromJSON(e))
                : []
        }
    },

    toJSON(message: TBattlePlayer): unknown {
        const obj: any = {}
        if (message.Pid !== undefined && message.Pid !== 0) {
            obj.Pid = Math.round(message.Pid)
        }
        if (message.Uid !== undefined && message.Uid !== 0) {
            obj.Uid = Math.round(message.Uid)
        }
        if (message.Uname !== undefined && message.Uname !== '') {
            obj.Uname = message.Uname
        }
        if (message.Level !== undefined && message.Level !== 0) {
            obj.Level = Math.round(message.Level)
        }
        if (message.PlayerCamp !== undefined && message.PlayerCamp !== 0) {
            obj.PlayerCamp = Math.round(message.PlayerCamp)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.FleetInfo !== undefined) {
            obj.FleetInfo = TBattleFleet.toJSON(message.FleetInfo)
        }
        if (message.OpenFunc?.length) {
            obj.OpenFunc = message.OpenFunc.map((e) => Math.round(e))
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            obj.BattleMode = Math.round(message.BattleMode)
        }
        if (message.RandomFactors?.length) {
            obj.RandomFactors = message.RandomFactors.map((e) => TRandomFactor.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattlePlayer>, I>>(base?: I): TBattlePlayer {
        return TBattlePlayer.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattlePlayer>, I>>(object: I): TBattlePlayer {
        const message = createBaseTBattlePlayer()
        message.Pid = object.Pid ?? 0
        message.Uid = object.Uid ?? 0
        message.Uname = object.Uname ?? ''
        message.Level = object.Level ?? 0
        message.PlayerCamp = object.PlayerCamp ?? 0
        message.Index = object.Index ?? 0
        message.FleetInfo = (object.FleetInfo !== undefined && object.FleetInfo !== null)
            ? TBattleFleet.fromPartial(object.FleetInfo)
            : undefined
        message.OpenFunc = object.OpenFunc?.map((e) => e) || []
        message.BattleMode = object.BattleMode ?? 0
        message.RandomFactors = object.RandomFactors?.map((e) => TRandomFactor.fromPartial(e)) ||
            []
        return message
    }
}

function createBaseTBattlePlayerList(): TBattlePlayerList {
    return { BattlePlayerList: [] }
}

export const TBattlePlayerList: MessageFns<TBattlePlayerList> = {
    encode(message: TBattlePlayerList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.BattlePlayerList) {
            TBattlePlayer.encode(v!, writer.uint32(10).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattlePlayerList {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattlePlayerList()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.BattlePlayerList.push(TBattlePlayer.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattlePlayerList {
        return {
            BattlePlayerList: globalThis.Array.isArray(object?.BattlePlayerList)
                ? object.BattlePlayerList.map((e: any) => TBattlePlayer.fromJSON(e))
                : []
        }
    },

    toJSON(message: TBattlePlayerList): unknown {
        const obj: any = {}
        if (message.BattlePlayerList?.length) {
            obj.BattlePlayerList = message.BattlePlayerList.map((e) => TBattlePlayer.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattlePlayerList>, I>>(base?: I): TBattlePlayerList {
        return TBattlePlayerList.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattlePlayerList>, I>>(object: I): TBattlePlayerList {
        const message = createBaseTBattlePlayerList()
        message.BattlePlayerList =
            object.BattlePlayerList?.map((e) => TBattlePlayer.fromPartial(e)) || []
        return message
    }
}

function createBaseTBattleShip(): TBattleShip {
    return {
        HeroId: 0,
        TemplateId: 0,
        Level: 0,
        Index: 0,
        Attr: [],
        CurHp: 0,
        Equips: [],
        PSkill: [],
        BathBuff: [],
        AdvEffectIdList: [],
        EquipGridNum: 0,
        Fashioning: 0,
        HurtPer: 0
    }
}

export const TBattleShip: MessageFns<TBattleShip> = {
    encode(message: TBattleShip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            writer.uint32(8).uint32(message.HeroId)
        }
        if (message.TemplateId !== undefined && message.TemplateId !== 0) {
            writer.uint32(16).int32(message.TemplateId)
        }
        if (message.Level !== undefined && message.Level !== 0) {
            writer.uint32(24).int32(message.Level)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(32).int32(message.Index)
        }
        for (const v of message.Attr) {
            THeroAttr.encode(v!, writer.uint32(42).fork()).join()
        }
        if (message.CurHp !== undefined && message.CurHp !== 0) {
            writer.uint32(48).uint64(message.CurHp)
        }
        for (const v of message.Equips) {
            TBattleEquip.encode(v!, writer.uint32(58).fork()).join()
        }
        for (const v of message.PSkill) {
            TFiledPSkillLv.encode(v!, writer.uint32(66).fork()).join()
        }
        for (const v of message.BathBuff) {
            writer.uint32(72).int32(v!)
        }
        for (const v of message.AdvEffectIdList) {
            writer.uint32(80).int32(v!)
        }
        if (message.EquipGridNum !== undefined && message.EquipGridNum !== 0) {
            writer.uint32(88).int32(message.EquipGridNum)
        }
        if (message.Fashioning !== undefined && message.Fashioning !== 0) {
            writer.uint32(96).int32(message.Fashioning)
        }
        if (message.HurtPer !== undefined && message.HurtPer !== 0) {
            writer.uint32(104).int32(message.HurtPer)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBattleShip {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBattleShip()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.HeroId = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.TemplateId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.Level = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.Attr.push(THeroAttr.decode(reader, reader.uint32()))
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.CurHp = longToNumber(reader.uint64())
                    continue
                }
                case 7: {
                    if (tag !== 58) {
                        break
                    }

                    message.Equips.push(TBattleEquip.decode(reader, reader.uint32()))
                    continue
                }
                case 8: {
                    if (tag !== 66) {
                        break
                    }

                    message.PSkill.push(TFiledPSkillLv.decode(reader, reader.uint32()))
                    continue
                }
                case 9: {
                    if (tag === 72) {
                        message.BathBuff.push(reader.int32())

                        continue
                    }

                    if (tag === 74) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.BathBuff.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 10: {
                    if (tag === 80) {
                        message.AdvEffectIdList.push(reader.int32())

                        continue
                    }

                    if (tag === 82) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.AdvEffectIdList.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 11: {
                    if (tag !== 88) {
                        break
                    }

                    message.EquipGridNum = reader.int32()
                    continue
                }
                case 12: {
                    if (tag !== 96) {
                        break
                    }

                    message.Fashioning = reader.int32()
                    continue
                }
                case 13: {
                    if (tag !== 104) {
                        break
                    }

                    message.HurtPer = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBattleShip {
        return {
            HeroId: isSet(object.HeroId) ? globalThis.Number(object.HeroId) : 0,
            TemplateId: isSet(object.TemplateId) ? globalThis.Number(object.TemplateId) : 0,
            Level: isSet(object.Level) ? globalThis.Number(object.Level) : 0,
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            Attr: globalThis.Array.isArray(object?.Attr)
                ? object.Attr.map((e: any) => THeroAttr.fromJSON(e))
                : [],
            CurHp: isSet(object.CurHp) ? globalThis.Number(object.CurHp) : 0,
            Equips: globalThis.Array.isArray(object?.Equips)
                ? object.Equips.map((e: any) => TBattleEquip.fromJSON(e))
                : [],
            PSkill: globalThis.Array.isArray(object?.PSkill)
                ? object.PSkill.map((e: any) => TFiledPSkillLv.fromJSON(e))
                : [],
            BathBuff: globalThis.Array.isArray(object?.BathBuff)
                ? object.BathBuff.map((e: any) => globalThis.Number(e))
                : [],
            AdvEffectIdList: globalThis.Array.isArray(object?.AdvEffectIdList)
                ? object.AdvEffectIdList.map((e: any) => globalThis.Number(e))
                : [],
            EquipGridNum: isSet(object.EquipGridNum) ? globalThis.Number(object.EquipGridNum) : 0,
            Fashioning: isSet(object.Fashioning) ? globalThis.Number(object.Fashioning) : 0,
            HurtPer: isSet(object.HurtPer) ? globalThis.Number(object.HurtPer) : 0
        }
    },

    toJSON(message: TBattleShip): unknown {
        const obj: any = {}
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            obj.HeroId = Math.round(message.HeroId)
        }
        if (message.TemplateId !== undefined && message.TemplateId !== 0) {
            obj.TemplateId = Math.round(message.TemplateId)
        }
        if (message.Level !== undefined && message.Level !== 0) {
            obj.Level = Math.round(message.Level)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.Attr?.length) {
            obj.Attr = message.Attr.map((e) => THeroAttr.toJSON(e))
        }
        if (message.CurHp !== undefined && message.CurHp !== 0) {
            obj.CurHp = Math.round(message.CurHp)
        }
        if (message.Equips?.length) {
            obj.Equips = message.Equips.map((e) => TBattleEquip.toJSON(e))
        }
        if (message.PSkill?.length) {
            obj.PSkill = message.PSkill.map((e) => TFiledPSkillLv.toJSON(e))
        }
        if (message.BathBuff?.length) {
            obj.BathBuff = message.BathBuff.map((e) => Math.round(e))
        }
        if (message.AdvEffectIdList?.length) {
            obj.AdvEffectIdList = message.AdvEffectIdList.map((e) => Math.round(e))
        }
        if (message.EquipGridNum !== undefined && message.EquipGridNum !== 0) {
            obj.EquipGridNum = Math.round(message.EquipGridNum)
        }
        if (message.Fashioning !== undefined && message.Fashioning !== 0) {
            obj.Fashioning = Math.round(message.Fashioning)
        }
        if (message.HurtPer !== undefined && message.HurtPer !== 0) {
            obj.HurtPer = Math.round(message.HurtPer)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBattleShip>, I>>(base?: I): TBattleShip {
        return TBattleShip.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBattleShip>, I>>(object: I): TBattleShip {
        const message = createBaseTBattleShip()
        message.HeroId = object.HeroId ?? 0
        message.TemplateId = object.TemplateId ?? 0
        message.Level = object.Level ?? 0
        message.Index = object.Index ?? 0
        message.Attr = object.Attr?.map((e) => THeroAttr.fromPartial(e)) || []
        message.CurHp = object.CurHp ?? 0
        message.Equips = object.Equips?.map((e) => TBattleEquip.fromPartial(e)) || []
        message.PSkill = object.PSkill?.map((e) => TFiledPSkillLv.fromPartial(e)) || []
        message.BathBuff = object.BathBuff?.map((e) => e) || []
        message.AdvEffectIdList = object.AdvEffectIdList?.map((e) => e) || []
        message.EquipGridNum = object.EquipGridNum ?? 0
        message.Fashioning = object.Fashioning ?? 0
        message.HurtPer = object.HurtPer ?? 0
        return message
    }
}

function createBaseTEquipPSkills(): TEquipPSkills {
    return { PSkillId: 0, PSkillLv: 0 }
}

export const TEquipPSkills: MessageFns<TEquipPSkills> = {
    encode(message: TEquipPSkills, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.PSkillId !== undefined && message.PSkillId !== 0) {
            writer.uint32(8).int32(message.PSkillId)
        }
        if (message.PSkillLv !== undefined && message.PSkillLv !== 0) {
            writer.uint32(16).int32(message.PSkillLv)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TEquipPSkills {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTEquipPSkills()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.PSkillId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.PSkillLv = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TEquipPSkills {
        return {
            PSkillId: isSet(object.PSkillId) ? globalThis.Number(object.PSkillId) : 0,
            PSkillLv: isSet(object.PSkillLv) ? globalThis.Number(object.PSkillLv) : 0
        }
    },

    toJSON(message: TEquipPSkills): unknown {
        const obj: any = {}
        if (message.PSkillId !== undefined && message.PSkillId !== 0) {
            obj.PSkillId = Math.round(message.PSkillId)
        }
        if (message.PSkillLv !== undefined && message.PSkillLv !== 0) {
            obj.PSkillLv = Math.round(message.PSkillLv)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TEquipPSkills>, I>>(base?: I): TEquipPSkills {
        return TEquipPSkills.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TEquipPSkills>, I>>(object: I): TEquipPSkills {
        const message = createBaseTEquipPSkills()
        message.PSkillId = object.PSkillId ?? 0
        message.PSkillLv = object.PSkillLv ?? 0
        return message
    }
}

function createBaseTFiledPSkillLv(): TFiledPSkillLv {
    return { PSkillId: 0, PSkillLv: 0 }
}

export const TFiledPSkillLv: MessageFns<TFiledPSkillLv> = {
    encode(message: TFiledPSkillLv, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.PSkillId !== undefined && message.PSkillId !== 0) {
            writer.uint32(8).int32(message.PSkillId)
        }
        if (message.PSkillLv !== undefined && message.PSkillLv !== 0) {
            writer.uint32(16).int32(message.PSkillLv)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TFiledPSkillLv {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTFiledPSkillLv()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.PSkillId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.PSkillLv = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TFiledPSkillLv {
        return {
            PSkillId: isSet(object.PSkillId) ? globalThis.Number(object.PSkillId) : 0,
            PSkillLv: isSet(object.PSkillLv) ? globalThis.Number(object.PSkillLv) : 0
        }
    },

    toJSON(message: TFiledPSkillLv): unknown {
        const obj: any = {}
        if (message.PSkillId !== undefined && message.PSkillId !== 0) {
            obj.PSkillId = Math.round(message.PSkillId)
        }
        if (message.PSkillLv !== undefined && message.PSkillLv !== 0) {
            obj.PSkillLv = Math.round(message.PSkillLv)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TFiledPSkillLv>, I>>(base?: I): TFiledPSkillLv {
        return TFiledPSkillLv.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TFiledPSkillLv>, I>>(object: I): TFiledPSkillLv {
        const message = createBaseTFiledPSkillLv()
        message.PSkillId = object.PSkillId ?? 0
        message.PSkillLv = object.PSkillLv ?? 0
        return message
    }
}

function createBaseTHeroAttr(): THeroAttr {
    return { AttrId: 0, AttrValue: 0 }
}

export const THeroAttr: MessageFns<THeroAttr> = {
    encode(message: THeroAttr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.AttrId !== undefined && message.AttrId !== 0) {
            writer.uint32(8).int32(message.AttrId)
        }
        if (message.AttrValue !== undefined && message.AttrValue !== 0) {
            writer.uint32(16).int32(message.AttrValue)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): THeroAttr {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTHeroAttr()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.AttrId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.AttrValue = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): THeroAttr {
        return {
            AttrId: isSet(object.AttrId) ? globalThis.Number(object.AttrId) : 0,
            AttrValue: isSet(object.AttrValue) ? globalThis.Number(object.AttrValue) : 0
        }
    },

    toJSON(message: THeroAttr): unknown {
        const obj: any = {}
        if (message.AttrId !== undefined && message.AttrId !== 0) {
            obj.AttrId = Math.round(message.AttrId)
        }
        if (message.AttrValue !== undefined && message.AttrValue !== 0) {
            obj.AttrValue = Math.round(message.AttrValue)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<THeroAttr>, I>>(base?: I): THeroAttr {
        return THeroAttr.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<THeroAttr>, I>>(object: I): THeroAttr {
        const message = createBaseTHeroAttr()
        message.AttrId = object.AttrId ?? 0
        message.AttrValue = object.AttrValue ?? 0
        return message
    }
}

function createBaseTRandomFactor(): TRandomFactor {
    return { Factors: [], GroupId: 0, SetId: 0 }
}

export const TRandomFactor: MessageFns<TRandomFactor> = {
    encode(message: TRandomFactor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.Factors) {
            writer.uint32(8).int32(v!)
        }
        if (message.GroupId !== undefined && message.GroupId !== 0) {
            writer.uint32(16).int32(message.GroupId)
        }
        if (message.SetId !== undefined && message.SetId !== 0) {
            writer.uint32(24).int32(message.SetId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TRandomFactor {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTRandomFactor()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.Factors.push(reader.int32())

                        continue
                    }

                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.Factors.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.GroupId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.SetId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TRandomFactor {
        return {
            Factors: globalThis.Array.isArray(object?.Factors)
                ? object.Factors.map((e: any) => globalThis.Number(e))
                : [],
            GroupId: isSet(object.GroupId) ? globalThis.Number(object.GroupId) : 0,
            SetId: isSet(object.SetId) ? globalThis.Number(object.SetId) : 0
        }
    },

    toJSON(message: TRandomFactor): unknown {
        const obj: any = {}
        if (message.Factors?.length) {
            obj.Factors = message.Factors.map((e) => Math.round(e))
        }
        if (message.GroupId !== undefined && message.GroupId !== 0) {
            obj.GroupId = Math.round(message.GroupId)
        }
        if (message.SetId !== undefined && message.SetId !== 0) {
            obj.SetId = Math.round(message.SetId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TRandomFactor>, I>>(base?: I): TRandomFactor {
        return TRandomFactor.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TRandomFactor>, I>>(object: I): TRandomFactor {
        const message = createBaseTRandomFactor()
        message.Factors = object.Factors?.map((e) => e) || []
        message.GroupId = object.GroupId ?? 0
        message.SetId = object.SetId ?? 0
        return message
    }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin ? T
    : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
    : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin ? P
    :
        & P
        & { [K in keyof P]: Exact<P[K], I[K]> }
        & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function longToNumber(int64: { toString(): string }): number {
    const num = globalThis.Number(int64.toString())
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER')
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER')
    }
    return num
}

function isSet(value: any): boolean {
    return value !== null && value !== undefined
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter
    decode(input: BinaryReader | Uint8Array, length?: number): T
    fromJSON(object: any): T
    toJSON(message: T): unknown
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
