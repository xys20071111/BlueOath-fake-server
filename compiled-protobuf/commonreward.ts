// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.4
// source: commonreward.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'

export const protobufPackage = 'commonreward'

export interface TCommonArrReward {
    Reward: TCommonReward[]
}

export interface TCommonExpReward {
    HeroId?: number | undefined
    Value?: number | undefined
}

export interface TCommonExtraReward {
    Key?: string | undefined
    Value?: number | undefined
}

export interface TCommonReward {
    Type?: number | undefined
    ConfigId?: number | undefined
    Num?: number | undefined
    Id?: number | undefined
}

function createBaseTCommonArrReward(): TCommonArrReward {
    return { Reward: [] }
}

export const TCommonArrReward: MessageFns<TCommonArrReward> = {
    encode(message: TCommonArrReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.Reward) {
            TCommonReward.encode(v!, writer.uint32(10).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCommonArrReward {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCommonArrReward()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.Reward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCommonArrReward {
        return {
            Reward: globalThis.Array.isArray(object?.Reward)
                ? object.Reward.map((e: any) => TCommonReward.fromJSON(e))
                : []
        }
    },

    toJSON(message: TCommonArrReward): unknown {
        const obj: any = {}
        if (message.Reward?.length) {
            obj.Reward = message.Reward.map((e) => TCommonReward.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCommonArrReward>, I>>(base?: I): TCommonArrReward {
        return TCommonArrReward.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCommonArrReward>, I>>(object: I): TCommonArrReward {
        const message = createBaseTCommonArrReward()
        message.Reward = object.Reward?.map((e) => TCommonReward.fromPartial(e)) || []
        return message
    }
}

function createBaseTCommonExpReward(): TCommonExpReward {
    return { HeroId: 0, Value: 0 }
}

export const TCommonExpReward: MessageFns<TCommonExpReward> = {
    encode(message: TCommonExpReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            writer.uint32(8).uint32(message.HeroId)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            writer.uint32(16).int32(message.Value)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCommonExpReward {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCommonExpReward()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.HeroId = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Value = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCommonExpReward {
        return {
            HeroId: isSet(object.HeroId) ? globalThis.Number(object.HeroId) : 0,
            Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0
        }
    },

    toJSON(message: TCommonExpReward): unknown {
        const obj: any = {}
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            obj.HeroId = Math.round(message.HeroId)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            obj.Value = Math.round(message.Value)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCommonExpReward>, I>>(base?: I): TCommonExpReward {
        return TCommonExpReward.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCommonExpReward>, I>>(object: I): TCommonExpReward {
        const message = createBaseTCommonExpReward()
        message.HeroId = object.HeroId ?? 0
        message.Value = object.Value ?? 0
        return message
    }
}

function createBaseTCommonExtraReward(): TCommonExtraReward {
    return { Key: '', Value: 0 }
}

export const TCommonExtraReward: MessageFns<TCommonExtraReward> = {
    encode(message: TCommonExtraReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Key !== undefined && message.Key !== '') {
            writer.uint32(10).string(message.Key)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            writer.uint32(16).int32(message.Value)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCommonExtraReward {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCommonExtraReward()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.Key = reader.string()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Value = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCommonExtraReward {
        return {
            Key: isSet(object.Key) ? globalThis.String(object.Key) : '',
            Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0
        }
    },

    toJSON(message: TCommonExtraReward): unknown {
        const obj: any = {}
        if (message.Key !== undefined && message.Key !== '') {
            obj.Key = message.Key
        }
        if (message.Value !== undefined && message.Value !== 0) {
            obj.Value = Math.round(message.Value)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCommonExtraReward>, I>>(base?: I): TCommonExtraReward {
        return TCommonExtraReward.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCommonExtraReward>, I>>(
        object: I
    ): TCommonExtraReward {
        const message = createBaseTCommonExtraReward()
        message.Key = object.Key ?? ''
        message.Value = object.Value ?? 0
        return message
    }
}

function createBaseTCommonReward(): TCommonReward {
    return { Type: 0, ConfigId: 0, Num: 0, Id: 0 }
}

export const TCommonReward: MessageFns<TCommonReward> = {
    encode(message: TCommonReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Type !== undefined && message.Type !== 0) {
            writer.uint32(8).int32(message.Type)
        }
        if (message.ConfigId !== undefined && message.ConfigId !== 0) {
            writer.uint32(16).int32(message.ConfigId)
        }
        if (message.Num !== undefined && message.Num !== 0) {
            writer.uint32(24).int32(message.Num)
        }
        if (message.Id !== undefined && message.Id !== 0) {
            writer.uint32(32).int32(message.Id)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCommonReward {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCommonReward()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Type = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.ConfigId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.Num = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.Id = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCommonReward {
        return {
            Type: isSet(object.Type) ? globalThis.Number(object.Type) : 0,
            ConfigId: isSet(object.ConfigId) ? globalThis.Number(object.ConfigId) : 0,
            Num: isSet(object.Num) ? globalThis.Number(object.Num) : 0,
            Id: isSet(object.Id) ? globalThis.Number(object.Id) : 0
        }
    },

    toJSON(message: TCommonReward): unknown {
        const obj: any = {}
        if (message.Type !== undefined && message.Type !== 0) {
            obj.Type = Math.round(message.Type)
        }
        if (message.ConfigId !== undefined && message.ConfigId !== 0) {
            obj.ConfigId = Math.round(message.ConfigId)
        }
        if (message.Num !== undefined && message.Num !== 0) {
            obj.Num = Math.round(message.Num)
        }
        if (message.Id !== undefined && message.Id !== 0) {
            obj.Id = Math.round(message.Id)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCommonReward>, I>>(base?: I): TCommonReward {
        return TCommonReward.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCommonReward>, I>>(object: I): TCommonReward {
        const message = createBaseTCommonReward()
        message.Type = object.Type ?? 0
        message.ConfigId = object.ConfigId ?? 0
        message.Num = object.Num ?? 0
        message.Id = object.Id ?? 0
        return message
    }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin ? T
    : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
    : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin ? P
    :
        & P
        & { [K in keyof P]: Exact<P[K], I[K]> }
        & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function isSet(value: any): boolean {
    return value !== null && value !== undefined
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter
    decode(input: BinaryReader | Uint8Array, length?: number): T
    fromJSON(object: any): T
    toJSON(message: T): unknown
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
