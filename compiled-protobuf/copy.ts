// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.4
// source: copy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import { TBattleEnemyFleet } from './battleenemy.ts'
import { TBattlePlayer, TBattlePlayerList, TRandomFactor } from './battleplayer.ts'
import { TCommonExpReward, TCommonExtraReward, TCommonReward } from './commonreward.ts'
import { TVerifyPackage } from './netoperation.ts'

export const protobufPackage = 'copy'

export interface TArchiveCopyOperation {
    frameNumber?: number | undefined
    data?: Uint8Array | undefined
}

export interface TAttackBaseArg {
    AttackType?: number | undefined
    CopyId?: number | undefined
    HeroIds: number[]
    EnemyId?: number | undefined
}

export interface TBaseHeroInfo {
    HeroId?: number | undefined
    Hp?: number | undefined
    IsMvp?: boolean | undefined
    IsBattle?: boolean | undefined
    BreakStatus?: number | undefined
    ExHeroInfo: TPassKvInfo[]
    OwnerUid?: number | undefined
}

export interface TBaseInfo {
    BaseId?: number | undefined
    Rid?: number | undefined
    StarLevel?: number | undefined
    IsRunningFight?: boolean | undefined
    LBPoint?: number | undefined
    FirstPassTime?: number | undefined
    DropHeroIds: number[]
    SfLv?: number | undefined
    SfPoint?: number | undefined
    SfInfo: TSfInfo[]
    SfDot?: boolean | undefined
    SfLvChoose?: number | undefined
}

export interface TCanAttackArg {
    CopyId?: number | undefined
}

export interface TCopyChooseSfLvArg {
    CopyId?: number | undefined
    SafeLv?: number | undefined
}

export interface TCopyRecord {
    CopyId?: number | undefined
    Index?: number | undefined
}

export interface TCopyRes {
    id?: number | undefined
    Reward: TCommonReward[]
}

export interface TCopySkipVcr {
    ShipInfoId?: number | undefined
    StartVcr?: boolean | undefined
    EndVcr?: boolean | undefined
}

export interface TDotBaseArg {
    CopyId?: number | undefined
}

export interface TGetRandomFactorArg {
    CopyId?: number | undefined
}

export interface TGetRandomFactorRet {
    Factors: TRandomFactor[]
    LastRefreshTime?: number | undefined
    IsShowTips?: boolean | undefined
}

export interface TPassBaseArg {
    BaseId?: number | undefined
    Rid?: number | undefined
    CacheId?: string | undefined
    RunningTime?: number | undefined
    MaxTimeScale?: number | undefined
    IsFlyAttack?: boolean | undefined
    IsRunningFight?: boolean | undefined
    Grade?: number | undefined
    MvpHeroId?: number | undefined
    BattleString?: string | undefined
    Evaluate: TPassEvaluate[]
    BattleTime?: number | undefined
    LBPoint?: number | undefined
    IsSupport?: boolean | undefined
    BattleType?: number | undefined
    Operation?: TArchiveCopyOperation | undefined
    FleetInfo: TPassFleetInfo[]
    HerosInfo: TBaseHeroInfo[]
    IsFinishMission?: boolean | undefined
    EnemyFleets: TBattleEnemyFleet[]
}

export interface TPassBaseRet {
    Reward: TCommonReward[]
    BattlePlayer?: TBattlePlayer | undefined
    Ret?: number | undefined
    Grade?: number | undefined
    ExReward: TCommonReward[]
    StarLv?: number | undefined
    Evaluate: TPassEvaluate[]
    PassTime?: number | undefined
    ExtraReward: TCommonExtraReward[]
    FirstPass?: number | undefined
    ExpReward: TCommonExpReward[]
    CopyId?: number | undefined
    BuildShipId?: number | undefined
    BuildShipReward: TCommonReward[]
    MissionReward: TCommonReward[]
}

export interface TPassEvaluate {
    Type?: number | undefined
    Value?: number | undefined
}

export interface TPassFleetInfo {
    EnemyId?: number | undefined
    EnemyInfo: TBaseHeroInfo[]
}

export interface TPassKvInfo {
    Type?: number | undefined
    Value?: number | undefined
}

export interface TQuitBaseArg {
    CopyId?: number | undefined
    IsRunningFight?: boolean | undefined
    IsPass?: boolean | undefined
    HeroInfo: TBaseHeroInfo[]
    VerifyPackage?: TVerifyPackage | undefined
    BattleMode?: number | undefined
}

export interface TResRewardArg {
    CopyId?: number | undefined
    ResId?: number | undefined
}

export interface TSfInfo {
    Type?: number | undefined
    Info: TSfStat[]
}

export interface TSfStat {
    Key?: number | undefined
    Value?: number | undefined
}

export interface TShipEquipGridInfo {
    HeroId?: number | undefined
    EquipGridNum?: number | undefined
}

export interface TStarInfo {
    ChapterId?: number | undefined
    StarNum?: number | undefined
    StarReward: TStarReward[]
    PassNum?: number | undefined
    Rank?: number | undefined
    StarRewardBox: TStarReward[]
}

export interface TStarReward {
    Index?: number | undefined
    RewardTime?: number | undefined
}

export interface TStarRewardArg {
    ChapterId?: number | undefined
    Index?: number | undefined
    IndexList: number[]
}

export interface TStarRewardRet {
    Reward: TCommonReward[]
}

export interface TStartBaseArg {
    ChapterId?: number | undefined
    CopyId?: number | undefined
    IsRunningFight?: boolean | undefined
    TacticId?: number | undefined
    CacheId?: string | undefined
    DailyGroupId?: number | undefined
    BattleMode?: number | undefined
    AnimMode?: number | undefined
    Power?: number | undefined
    ExBuff: number[]
    HeroList: TStartBaseHeroList[]
    RoomId?: number | undefined
    MatchType?: number | undefined
}

export interface TStartBaseHero {
    HeroId?: number | undefined
    HeroTid?: number | undefined
}

export interface TStartBaseHeroList {
    HeroIdList: number[]
    Index?: number | undefined
    StrategyId?: number | undefined
}

export interface TStartBaseRet {
    BattlePlayer?: TBattlePlayerList | undefined
    RandomSeed?: number | undefined
    Rid?: number | undefined
    arrRes: TCopyRes[]
    EnemyFleet: number[]
    CopyId?: number | undefined
    CopyType?: number | undefined
    CopyPass?: boolean | undefined
    BossProgress?: number | undefined
    IsRunningFight?: boolean | undefined
    ShipEquipGridInfo: TShipEquipGridInfo[]
    RandomFactors: TRandomFactor[]
    SafeLv?: number | undefined
    Verify?: TVerifyPackage | undefined
    ExtraBattlePlayerList: TBattlePlayerList[]
    Token?: string | undefined
    SkipVcr: TCopySkipVcr[]
    BattleMode?: number | undefined
    IsFinal?: boolean | undefined
    AnimMode?: number | undefined
    WeatherGroupId?: number | undefined
    CopyMission: number[]
    EnemyFleets: TBattleEnemyFleet[]
    ConfigData: TPassEvaluate[]
    MatchType?: number | undefined
}

export interface TTestPassArg {
    StartCopyId?: number | undefined
    EndCopyId?: number | undefined
}

export interface TTestPassRet {
    CopyIdList: number[]
}

export interface TUnlockedCopyArg {
    CopyId?: number | undefined
}

export interface TUserCopyInfo {
    BaseInfo: TBaseInfo[]
    MaxCopyId?: number | undefined
    CopyType?: number | undefined
    StarInfo: TStarInfo[]
    PassCopyCount: TPassKvInfo[]
}

function createBaseTArchiveCopyOperation(): TArchiveCopyOperation {
    return { frameNumber: 0, data: new Uint8Array(0) }
}

export const TArchiveCopyOperation: MessageFns<TArchiveCopyOperation> = {
    encode(
        message: TArchiveCopyOperation,
        writer: BinaryWriter = new BinaryWriter()
    ): BinaryWriter {
        if (message.frameNumber !== undefined && message.frameNumber !== 0) {
            writer.uint32(8).int32(message.frameNumber)
        }
        if (message.data !== undefined && message.data.length !== 0) {
            writer.uint32(18).bytes(message.data)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TArchiveCopyOperation {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTArchiveCopyOperation()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.frameNumber = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.data = reader.bytes()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TArchiveCopyOperation {
        return {
            frameNumber: isSet(object.frameNumber) ? globalThis.Number(object.frameNumber) : 0,
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0)
        }
    },

    toJSON(message: TArchiveCopyOperation): unknown {
        const obj: any = {}
        if (message.frameNumber !== undefined && message.frameNumber !== 0) {
            obj.frameNumber = Math.round(message.frameNumber)
        }
        if (message.data !== undefined && message.data.length !== 0) {
            obj.data = base64FromBytes(message.data)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TArchiveCopyOperation>, I>>(
        base?: I
    ): TArchiveCopyOperation {
        return TArchiveCopyOperation.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TArchiveCopyOperation>, I>>(
        object: I
    ): TArchiveCopyOperation {
        const message = createBaseTArchiveCopyOperation()
        message.frameNumber = object.frameNumber ?? 0
        message.data = object.data ?? new Uint8Array(0)
        return message
    }
}

function createBaseTAttackBaseArg(): TAttackBaseArg {
    return { AttackType: 0, CopyId: 0, HeroIds: [], EnemyId: 0 }
}

export const TAttackBaseArg: MessageFns<TAttackBaseArg> = {
    encode(message: TAttackBaseArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.AttackType !== undefined && message.AttackType !== 0) {
            writer.uint32(8).int32(message.AttackType)
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(16).int32(message.CopyId)
        }
        for (const v of message.HeroIds) {
            writer.uint32(24).uint32(v!)
        }
        if (message.EnemyId !== undefined && message.EnemyId !== 0) {
            writer.uint32(32).int32(message.EnemyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TAttackBaseArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTAttackBaseArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.AttackType = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag === 24) {
                        message.HeroIds.push(reader.uint32())

                        continue
                    }

                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.HeroIds.push(reader.uint32())
                        }

                        continue
                    }

                    break
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.EnemyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TAttackBaseArg {
        return {
            AttackType: isSet(object.AttackType) ? globalThis.Number(object.AttackType) : 0,
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            HeroIds: globalThis.Array.isArray(object?.HeroIds)
                ? object.HeroIds.map((e: any) => globalThis.Number(e))
                : [],
            EnemyId: isSet(object.EnemyId) ? globalThis.Number(object.EnemyId) : 0
        }
    },

    toJSON(message: TAttackBaseArg): unknown {
        const obj: any = {}
        if (message.AttackType !== undefined && message.AttackType !== 0) {
            obj.AttackType = Math.round(message.AttackType)
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.HeroIds?.length) {
            obj.HeroIds = message.HeroIds.map((e) => Math.round(e))
        }
        if (message.EnemyId !== undefined && message.EnemyId !== 0) {
            obj.EnemyId = Math.round(message.EnemyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TAttackBaseArg>, I>>(base?: I): TAttackBaseArg {
        return TAttackBaseArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TAttackBaseArg>, I>>(object: I): TAttackBaseArg {
        const message = createBaseTAttackBaseArg()
        message.AttackType = object.AttackType ?? 0
        message.CopyId = object.CopyId ?? 0
        message.HeroIds = object.HeroIds?.map((e) => e) || []
        message.EnemyId = object.EnemyId ?? 0
        return message
    }
}

function createBaseTBaseHeroInfo(): TBaseHeroInfo {
    return {
        HeroId: 0,
        Hp: 0,
        IsMvp: false,
        IsBattle: false,
        BreakStatus: 0,
        ExHeroInfo: [],
        OwnerUid: 0
    }
}

export const TBaseHeroInfo: MessageFns<TBaseHeroInfo> = {
    encode(message: TBaseHeroInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            writer.uint32(8).uint32(message.HeroId)
        }
        if (message.Hp !== undefined && message.Hp !== 0) {
            writer.uint32(16).uint64(message.Hp)
        }
        if (message.IsMvp !== undefined && message.IsMvp !== false) {
            writer.uint32(24).bool(message.IsMvp)
        }
        if (message.IsBattle !== undefined && message.IsBattle !== false) {
            writer.uint32(32).bool(message.IsBattle)
        }
        if (message.BreakStatus !== undefined && message.BreakStatus !== 0) {
            writer.uint32(40).int32(message.BreakStatus)
        }
        for (const v of message.ExHeroInfo) {
            TPassKvInfo.encode(v!, writer.uint32(50).fork()).join()
        }
        if (message.OwnerUid !== undefined && message.OwnerUid !== 0) {
            writer.uint32(56).uint64(message.OwnerUid)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBaseHeroInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBaseHeroInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.HeroId = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Hp = longToNumber(reader.uint64())
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.IsMvp = reader.bool()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.IsBattle = reader.bool()
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.BreakStatus = reader.int32()
                    continue
                }
                case 6: {
                    if (tag !== 50) {
                        break
                    }

                    message.ExHeroInfo.push(TPassKvInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 7: {
                    if (tag !== 56) {
                        break
                    }

                    message.OwnerUid = longToNumber(reader.uint64())
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBaseHeroInfo {
        return {
            HeroId: isSet(object.HeroId) ? globalThis.Number(object.HeroId) : 0,
            Hp: isSet(object.Hp) ? globalThis.Number(object.Hp) : 0,
            IsMvp: isSet(object.IsMvp) ? globalThis.Boolean(object.IsMvp) : false,
            IsBattle: isSet(object.IsBattle) ? globalThis.Boolean(object.IsBattle) : false,
            BreakStatus: isSet(object.BreakStatus) ? globalThis.Number(object.BreakStatus) : 0,
            ExHeroInfo: globalThis.Array.isArray(object?.ExHeroInfo)
                ? object.ExHeroInfo.map((e: any) => TPassKvInfo.fromJSON(e))
                : [],
            OwnerUid: isSet(object.OwnerUid) ? globalThis.Number(object.OwnerUid) : 0
        }
    },

    toJSON(message: TBaseHeroInfo): unknown {
        const obj: any = {}
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            obj.HeroId = Math.round(message.HeroId)
        }
        if (message.Hp !== undefined && message.Hp !== 0) {
            obj.Hp = Math.round(message.Hp)
        }
        if (message.IsMvp !== undefined && message.IsMvp !== false) {
            obj.IsMvp = message.IsMvp
        }
        if (message.IsBattle !== undefined && message.IsBattle !== false) {
            obj.IsBattle = message.IsBattle
        }
        if (message.BreakStatus !== undefined && message.BreakStatus !== 0) {
            obj.BreakStatus = Math.round(message.BreakStatus)
        }
        if (message.ExHeroInfo?.length) {
            obj.ExHeroInfo = message.ExHeroInfo.map((e) => TPassKvInfo.toJSON(e))
        }
        if (message.OwnerUid !== undefined && message.OwnerUid !== 0) {
            obj.OwnerUid = Math.round(message.OwnerUid)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBaseHeroInfo>, I>>(base?: I): TBaseHeroInfo {
        return TBaseHeroInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBaseHeroInfo>, I>>(object: I): TBaseHeroInfo {
        const message = createBaseTBaseHeroInfo()
        message.HeroId = object.HeroId ?? 0
        message.Hp = object.Hp ?? 0
        message.IsMvp = object.IsMvp ?? false
        message.IsBattle = object.IsBattle ?? false
        message.BreakStatus = object.BreakStatus ?? 0
        message.ExHeroInfo = object.ExHeroInfo?.map((e) => TPassKvInfo.fromPartial(e)) || []
        message.OwnerUid = object.OwnerUid ?? 0
        return message
    }
}

function createBaseTBaseInfo(): TBaseInfo {
    return {
        BaseId: 0,
        Rid: 0,
        StarLevel: 0,
        IsRunningFight: false,
        LBPoint: 0,
        FirstPassTime: 0,
        DropHeroIds: [],
        SfLv: 0,
        SfPoint: 0,
        SfInfo: [],
        SfDot: false,
        SfLvChoose: 0
    }
}

export const TBaseInfo: MessageFns<TBaseInfo> = {
    encode(message: TBaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.BaseId !== undefined && message.BaseId !== 0) {
            writer.uint32(8).int32(message.BaseId)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            writer.uint32(16).int32(message.Rid)
        }
        if (message.StarLevel !== undefined && message.StarLevel !== 0) {
            writer.uint32(24).int32(message.StarLevel)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            writer.uint32(32).bool(message.IsRunningFight)
        }
        if (message.LBPoint !== undefined && message.LBPoint !== 0) {
            writer.uint32(40).int32(message.LBPoint)
        }
        if (message.FirstPassTime !== undefined && message.FirstPassTime !== 0) {
            writer.uint32(48).int32(message.FirstPassTime)
        }
        for (const v of message.DropHeroIds) {
            writer.uint32(56).int32(v!)
        }
        if (message.SfLv !== undefined && message.SfLv !== 0) {
            writer.uint32(64).int32(message.SfLv)
        }
        if (message.SfPoint !== undefined && message.SfPoint !== 0) {
            writer.uint32(77).float(message.SfPoint)
        }
        for (const v of message.SfInfo) {
            TSfInfo.encode(v!, writer.uint32(82).fork()).join()
        }
        if (message.SfDot !== undefined && message.SfDot !== false) {
            writer.uint32(88).bool(message.SfDot)
        }
        if (message.SfLvChoose !== undefined && message.SfLvChoose !== 0) {
            writer.uint32(96).int32(message.SfLvChoose)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TBaseInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTBaseInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.BaseId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Rid = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.StarLevel = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.IsRunningFight = reader.bool()
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.LBPoint = reader.int32()
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.FirstPassTime = reader.int32()
                    continue
                }
                case 7: {
                    if (tag === 56) {
                        message.DropHeroIds.push(reader.int32())

                        continue
                    }

                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.DropHeroIds.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.SfLv = reader.int32()
                    continue
                }
                case 9: {
                    if (tag !== 77) {
                        break
                    }

                    message.SfPoint = reader.float()
                    continue
                }
                case 10: {
                    if (tag !== 82) {
                        break
                    }

                    message.SfInfo.push(TSfInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 11: {
                    if (tag !== 88) {
                        break
                    }

                    message.SfDot = reader.bool()
                    continue
                }
                case 12: {
                    if (tag !== 96) {
                        break
                    }

                    message.SfLvChoose = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TBaseInfo {
        return {
            BaseId: isSet(object.BaseId) ? globalThis.Number(object.BaseId) : 0,
            Rid: isSet(object.Rid) ? globalThis.Number(object.Rid) : 0,
            StarLevel: isSet(object.StarLevel) ? globalThis.Number(object.StarLevel) : 0,
            IsRunningFight: isSet(object.IsRunningFight)
                ? globalThis.Boolean(object.IsRunningFight)
                : false,
            LBPoint: isSet(object.LBPoint) ? globalThis.Number(object.LBPoint) : 0,
            FirstPassTime: isSet(object.FirstPassTime)
                ? globalThis.Number(object.FirstPassTime)
                : 0,
            DropHeroIds: globalThis.Array.isArray(object?.DropHeroIds)
                ? object.DropHeroIds.map((e: any) => globalThis.Number(e))
                : [],
            SfLv: isSet(object.SfLv) ? globalThis.Number(object.SfLv) : 0,
            SfPoint: isSet(object.SfPoint) ? globalThis.Number(object.SfPoint) : 0,
            SfInfo: globalThis.Array.isArray(object?.SfInfo)
                ? object.SfInfo.map((e: any) => TSfInfo.fromJSON(e))
                : [],
            SfDot: isSet(object.SfDot) ? globalThis.Boolean(object.SfDot) : false,
            SfLvChoose: isSet(object.SfLvChoose) ? globalThis.Number(object.SfLvChoose) : 0
        }
    },

    toJSON(message: TBaseInfo): unknown {
        const obj: any = {}
        if (message.BaseId !== undefined && message.BaseId !== 0) {
            obj.BaseId = Math.round(message.BaseId)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            obj.Rid = Math.round(message.Rid)
        }
        if (message.StarLevel !== undefined && message.StarLevel !== 0) {
            obj.StarLevel = Math.round(message.StarLevel)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            obj.IsRunningFight = message.IsRunningFight
        }
        if (message.LBPoint !== undefined && message.LBPoint !== 0) {
            obj.LBPoint = Math.round(message.LBPoint)
        }
        if (message.FirstPassTime !== undefined && message.FirstPassTime !== 0) {
            obj.FirstPassTime = Math.round(message.FirstPassTime)
        }
        if (message.DropHeroIds?.length) {
            obj.DropHeroIds = message.DropHeroIds.map((e) => Math.round(e))
        }
        if (message.SfLv !== undefined && message.SfLv !== 0) {
            obj.SfLv = Math.round(message.SfLv)
        }
        if (message.SfPoint !== undefined && message.SfPoint !== 0) {
            obj.SfPoint = message.SfPoint
        }
        if (message.SfInfo?.length) {
            obj.SfInfo = message.SfInfo.map((e) => TSfInfo.toJSON(e))
        }
        if (message.SfDot !== undefined && message.SfDot !== false) {
            obj.SfDot = message.SfDot
        }
        if (message.SfLvChoose !== undefined && message.SfLvChoose !== 0) {
            obj.SfLvChoose = Math.round(message.SfLvChoose)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TBaseInfo>, I>>(base?: I): TBaseInfo {
        return TBaseInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TBaseInfo>, I>>(object: I): TBaseInfo {
        const message = createBaseTBaseInfo()
        message.BaseId = object.BaseId ?? 0
        message.Rid = object.Rid ?? 0
        message.StarLevel = object.StarLevel ?? 0
        message.IsRunningFight = object.IsRunningFight ?? false
        message.LBPoint = object.LBPoint ?? 0
        message.FirstPassTime = object.FirstPassTime ?? 0
        message.DropHeroIds = object.DropHeroIds?.map((e) => e) || []
        message.SfLv = object.SfLv ?? 0
        message.SfPoint = object.SfPoint ?? 0
        message.SfInfo = object.SfInfo?.map((e) => TSfInfo.fromPartial(e)) || []
        message.SfDot = object.SfDot ?? false
        message.SfLvChoose = object.SfLvChoose ?? 0
        return message
    }
}

function createBaseTCanAttackArg(): TCanAttackArg {
    return { CopyId: 0 }
}

export const TCanAttackArg: MessageFns<TCanAttackArg> = {
    encode(message: TCanAttackArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCanAttackArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCanAttackArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCanAttackArg {
        return { CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0 }
    },

    toJSON(message: TCanAttackArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCanAttackArg>, I>>(base?: I): TCanAttackArg {
        return TCanAttackArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCanAttackArg>, I>>(object: I): TCanAttackArg {
        const message = createBaseTCanAttackArg()
        message.CopyId = object.CopyId ?? 0
        return message
    }
}

function createBaseTCopyChooseSfLvArg(): TCopyChooseSfLvArg {
    return { CopyId: 0, SafeLv: 0 }
}

export const TCopyChooseSfLvArg: MessageFns<TCopyChooseSfLvArg> = {
    encode(message: TCopyChooseSfLvArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        if (message.SafeLv !== undefined && message.SafeLv !== 0) {
            writer.uint32(16).int32(message.SafeLv)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCopyChooseSfLvArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCopyChooseSfLvArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.SafeLv = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCopyChooseSfLvArg {
        return {
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            SafeLv: isSet(object.SafeLv) ? globalThis.Number(object.SafeLv) : 0
        }
    },

    toJSON(message: TCopyChooseSfLvArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.SafeLv !== undefined && message.SafeLv !== 0) {
            obj.SafeLv = Math.round(message.SafeLv)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCopyChooseSfLvArg>, I>>(base?: I): TCopyChooseSfLvArg {
        return TCopyChooseSfLvArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCopyChooseSfLvArg>, I>>(
        object: I
    ): TCopyChooseSfLvArg {
        const message = createBaseTCopyChooseSfLvArg()
        message.CopyId = object.CopyId ?? 0
        message.SafeLv = object.SafeLv ?? 0
        return message
    }
}

function createBaseTCopyRecord(): TCopyRecord {
    return { CopyId: 0, Index: 0 }
}

export const TCopyRecord: MessageFns<TCopyRecord> = {
    encode(message: TCopyRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(16).int32(message.Index)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCopyRecord {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCopyRecord()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCopyRecord {
        return {
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0
        }
    },

    toJSON(message: TCopyRecord): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCopyRecord>, I>>(base?: I): TCopyRecord {
        return TCopyRecord.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCopyRecord>, I>>(object: I): TCopyRecord {
        const message = createBaseTCopyRecord()
        message.CopyId = object.CopyId ?? 0
        message.Index = object.Index ?? 0
        return message
    }
}

function createBaseTCopyRes(): TCopyRes {
    return { id: 0, Reward: [] }
}

export const TCopyRes: MessageFns<TCopyRes> = {
    encode(message: TCopyRes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.id !== undefined && message.id !== 0) {
            writer.uint32(8).int32(message.id)
        }
        for (const v of message.Reward) {
            TCommonReward.encode(v!, writer.uint32(18).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCopyRes {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCopyRes()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.id = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.Reward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCopyRes {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            Reward: globalThis.Array.isArray(object?.Reward)
                ? object.Reward.map((e: any) => TCommonReward.fromJSON(e))
                : []
        }
    },

    toJSON(message: TCopyRes): unknown {
        const obj: any = {}
        if (message.id !== undefined && message.id !== 0) {
            obj.id = Math.round(message.id)
        }
        if (message.Reward?.length) {
            obj.Reward = message.Reward.map((e) => TCommonReward.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCopyRes>, I>>(base?: I): TCopyRes {
        return TCopyRes.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCopyRes>, I>>(object: I): TCopyRes {
        const message = createBaseTCopyRes()
        message.id = object.id ?? 0
        message.Reward = object.Reward?.map((e) => TCommonReward.fromPartial(e)) || []
        return message
    }
}

function createBaseTCopySkipVcr(): TCopySkipVcr {
    return { ShipInfoId: 0, StartVcr: false, EndVcr: false }
}

export const TCopySkipVcr: MessageFns<TCopySkipVcr> = {
    encode(message: TCopySkipVcr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.ShipInfoId !== undefined && message.ShipInfoId !== 0) {
            writer.uint32(8).int32(message.ShipInfoId)
        }
        if (message.StartVcr !== undefined && message.StartVcr !== false) {
            writer.uint32(16).bool(message.StartVcr)
        }
        if (message.EndVcr !== undefined && message.EndVcr !== false) {
            writer.uint32(24).bool(message.EndVcr)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TCopySkipVcr {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTCopySkipVcr()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.ShipInfoId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.StartVcr = reader.bool()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.EndVcr = reader.bool()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TCopySkipVcr {
        return {
            ShipInfoId: isSet(object.ShipInfoId) ? globalThis.Number(object.ShipInfoId) : 0,
            StartVcr: isSet(object.StartVcr) ? globalThis.Boolean(object.StartVcr) : false,
            EndVcr: isSet(object.EndVcr) ? globalThis.Boolean(object.EndVcr) : false
        }
    },

    toJSON(message: TCopySkipVcr): unknown {
        const obj: any = {}
        if (message.ShipInfoId !== undefined && message.ShipInfoId !== 0) {
            obj.ShipInfoId = Math.round(message.ShipInfoId)
        }
        if (message.StartVcr !== undefined && message.StartVcr !== false) {
            obj.StartVcr = message.StartVcr
        }
        if (message.EndVcr !== undefined && message.EndVcr !== false) {
            obj.EndVcr = message.EndVcr
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TCopySkipVcr>, I>>(base?: I): TCopySkipVcr {
        return TCopySkipVcr.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TCopySkipVcr>, I>>(object: I): TCopySkipVcr {
        const message = createBaseTCopySkipVcr()
        message.ShipInfoId = object.ShipInfoId ?? 0
        message.StartVcr = object.StartVcr ?? false
        message.EndVcr = object.EndVcr ?? false
        return message
    }
}

function createBaseTDotBaseArg(): TDotBaseArg {
    return { CopyId: 0 }
}

export const TDotBaseArg: MessageFns<TDotBaseArg> = {
    encode(message: TDotBaseArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TDotBaseArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTDotBaseArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TDotBaseArg {
        return { CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0 }
    },

    toJSON(message: TDotBaseArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TDotBaseArg>, I>>(base?: I): TDotBaseArg {
        return TDotBaseArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TDotBaseArg>, I>>(object: I): TDotBaseArg {
        const message = createBaseTDotBaseArg()
        message.CopyId = object.CopyId ?? 0
        return message
    }
}

function createBaseTGetRandomFactorArg(): TGetRandomFactorArg {
    return { CopyId: 0 }
}

export const TGetRandomFactorArg: MessageFns<TGetRandomFactorArg> = {
    encode(message: TGetRandomFactorArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TGetRandomFactorArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTGetRandomFactorArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TGetRandomFactorArg {
        return { CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0 }
    },

    toJSON(message: TGetRandomFactorArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TGetRandomFactorArg>, I>>(base?: I): TGetRandomFactorArg {
        return TGetRandomFactorArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TGetRandomFactorArg>, I>>(
        object: I
    ): TGetRandomFactorArg {
        const message = createBaseTGetRandomFactorArg()
        message.CopyId = object.CopyId ?? 0
        return message
    }
}

function createBaseTGetRandomFactorRet(): TGetRandomFactorRet {
    return { Factors: [], LastRefreshTime: 0, IsShowTips: false }
}

export const TGetRandomFactorRet: MessageFns<TGetRandomFactorRet> = {
    encode(message: TGetRandomFactorRet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.Factors) {
            TRandomFactor.encode(v!, writer.uint32(10).fork()).join()
        }
        if (message.LastRefreshTime !== undefined && message.LastRefreshTime !== 0) {
            writer.uint32(16).int32(message.LastRefreshTime)
        }
        if (message.IsShowTips !== undefined && message.IsShowTips !== false) {
            writer.uint32(24).bool(message.IsShowTips)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TGetRandomFactorRet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTGetRandomFactorRet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.Factors.push(TRandomFactor.decode(reader, reader.uint32()))
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.LastRefreshTime = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.IsShowTips = reader.bool()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TGetRandomFactorRet {
        return {
            Factors: globalThis.Array.isArray(object?.Factors)
                ? object.Factors.map((e: any) => TRandomFactor.fromJSON(e))
                : [],
            LastRefreshTime: isSet(object.LastRefreshTime)
                ? globalThis.Number(object.LastRefreshTime)
                : 0,
            IsShowTips: isSet(object.IsShowTips) ? globalThis.Boolean(object.IsShowTips) : false
        }
    },

    toJSON(message: TGetRandomFactorRet): unknown {
        const obj: any = {}
        if (message.Factors?.length) {
            obj.Factors = message.Factors.map((e) => TRandomFactor.toJSON(e))
        }
        if (message.LastRefreshTime !== undefined && message.LastRefreshTime !== 0) {
            obj.LastRefreshTime = Math.round(message.LastRefreshTime)
        }
        if (message.IsShowTips !== undefined && message.IsShowTips !== false) {
            obj.IsShowTips = message.IsShowTips
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TGetRandomFactorRet>, I>>(base?: I): TGetRandomFactorRet {
        return TGetRandomFactorRet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TGetRandomFactorRet>, I>>(
        object: I
    ): TGetRandomFactorRet {
        const message = createBaseTGetRandomFactorRet()
        message.Factors = object.Factors?.map((e) => TRandomFactor.fromPartial(e)) || []
        message.LastRefreshTime = object.LastRefreshTime ?? 0
        message.IsShowTips = object.IsShowTips ?? false
        return message
    }
}

function createBaseTPassBaseArg(): TPassBaseArg {
    return {
        BaseId: 0,
        Rid: 0,
        CacheId: '',
        RunningTime: 0,
        MaxTimeScale: 0,
        IsFlyAttack: false,
        IsRunningFight: false,
        Grade: 0,
        MvpHeroId: 0,
        BattleString: '',
        Evaluate: [],
        BattleTime: 0,
        LBPoint: 0,
        IsSupport: false,
        BattleType: 0,
        Operation: undefined,
        FleetInfo: [],
        HerosInfo: [],
        IsFinishMission: false,
        EnemyFleets: []
    }
}

export const TPassBaseArg: MessageFns<TPassBaseArg> = {
    encode(message: TPassBaseArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.BaseId !== undefined && message.BaseId !== 0) {
            writer.uint32(8).int32(message.BaseId)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            writer.uint32(16).int32(message.Rid)
        }
        if (message.CacheId !== undefined && message.CacheId !== '') {
            writer.uint32(26).string(message.CacheId)
        }
        if (message.RunningTime !== undefined && message.RunningTime !== 0) {
            writer.uint32(32).int32(message.RunningTime)
        }
        if (message.MaxTimeScale !== undefined && message.MaxTimeScale !== 0) {
            writer.uint32(45).float(message.MaxTimeScale)
        }
        if (message.IsFlyAttack !== undefined && message.IsFlyAttack !== false) {
            writer.uint32(48).bool(message.IsFlyAttack)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            writer.uint32(56).bool(message.IsRunningFight)
        }
        if (message.Grade !== undefined && message.Grade !== 0) {
            writer.uint32(64).int32(message.Grade)
        }
        if (message.MvpHeroId !== undefined && message.MvpHeroId !== 0) {
            writer.uint32(72).uint32(message.MvpHeroId)
        }
        if (message.BattleString !== undefined && message.BattleString !== '') {
            writer.uint32(82).string(message.BattleString)
        }
        for (const v of message.Evaluate) {
            TPassEvaluate.encode(v!, writer.uint32(90).fork()).join()
        }
        if (message.BattleTime !== undefined && message.BattleTime !== 0) {
            writer.uint32(96).int32(message.BattleTime)
        }
        if (message.LBPoint !== undefined && message.LBPoint !== 0) {
            writer.uint32(104).int32(message.LBPoint)
        }
        if (message.IsSupport !== undefined && message.IsSupport !== false) {
            writer.uint32(112).bool(message.IsSupport)
        }
        if (message.BattleType !== undefined && message.BattleType !== 0) {
            writer.uint32(120).int32(message.BattleType)
        }
        if (message.Operation !== undefined) {
            TArchiveCopyOperation.encode(message.Operation, writer.uint32(130).fork()).join()
        }
        for (const v of message.FleetInfo) {
            TPassFleetInfo.encode(v!, writer.uint32(138).fork()).join()
        }
        for (const v of message.HerosInfo) {
            TBaseHeroInfo.encode(v!, writer.uint32(146).fork()).join()
        }
        if (message.IsFinishMission !== undefined && message.IsFinishMission !== false) {
            writer.uint32(152).bool(message.IsFinishMission)
        }
        for (const v of message.EnemyFleets) {
            TBattleEnemyFleet.encode(v!, writer.uint32(162).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TPassBaseArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTPassBaseArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.BaseId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Rid = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 26) {
                        break
                    }

                    message.CacheId = reader.string()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.RunningTime = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 45) {
                        break
                    }

                    message.MaxTimeScale = reader.float()
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.IsFlyAttack = reader.bool()
                    continue
                }
                case 7: {
                    if (tag !== 56) {
                        break
                    }

                    message.IsRunningFight = reader.bool()
                    continue
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.Grade = reader.int32()
                    continue
                }
                case 9: {
                    if (tag !== 72) {
                        break
                    }

                    message.MvpHeroId = reader.uint32()
                    continue
                }
                case 10: {
                    if (tag !== 82) {
                        break
                    }

                    message.BattleString = reader.string()
                    continue
                }
                case 11: {
                    if (tag !== 90) {
                        break
                    }

                    message.Evaluate.push(TPassEvaluate.decode(reader, reader.uint32()))
                    continue
                }
                case 12: {
                    if (tag !== 96) {
                        break
                    }

                    message.BattleTime = reader.int32()
                    continue
                }
                case 13: {
                    if (tag !== 104) {
                        break
                    }

                    message.LBPoint = reader.int32()
                    continue
                }
                case 14: {
                    if (tag !== 112) {
                        break
                    }

                    message.IsSupport = reader.bool()
                    continue
                }
                case 15: {
                    if (tag !== 120) {
                        break
                    }

                    message.BattleType = reader.int32()
                    continue
                }
                case 16: {
                    if (tag !== 130) {
                        break
                    }

                    message.Operation = TArchiveCopyOperation.decode(reader, reader.uint32())
                    continue
                }
                case 17: {
                    if (tag !== 138) {
                        break
                    }

                    message.FleetInfo.push(TPassFleetInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 18: {
                    if (tag !== 146) {
                        break
                    }

                    message.HerosInfo.push(TBaseHeroInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 19: {
                    if (tag !== 152) {
                        break
                    }

                    message.IsFinishMission = reader.bool()
                    continue
                }
                case 20: {
                    if (tag !== 162) {
                        break
                    }

                    message.EnemyFleets.push(TBattleEnemyFleet.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TPassBaseArg {
        return {
            BaseId: isSet(object.BaseId) ? globalThis.Number(object.BaseId) : 0,
            Rid: isSet(object.Rid) ? globalThis.Number(object.Rid) : 0,
            CacheId: isSet(object.CacheId) ? globalThis.String(object.CacheId) : '',
            RunningTime: isSet(object.RunningTime) ? globalThis.Number(object.RunningTime) : 0,
            MaxTimeScale: isSet(object.MaxTimeScale) ? globalThis.Number(object.MaxTimeScale) : 0,
            IsFlyAttack: isSet(object.IsFlyAttack)
                ? globalThis.Boolean(object.IsFlyAttack)
                : false,
            IsRunningFight: isSet(object.IsRunningFight)
                ? globalThis.Boolean(object.IsRunningFight)
                : false,
            Grade: isSet(object.Grade) ? globalThis.Number(object.Grade) : 0,
            MvpHeroId: isSet(object.MvpHeroId) ? globalThis.Number(object.MvpHeroId) : 0,
            BattleString: isSet(object.BattleString) ? globalThis.String(object.BattleString) : '',
            Evaluate: globalThis.Array.isArray(object?.Evaluate)
                ? object.Evaluate.map((e: any) => TPassEvaluate.fromJSON(e))
                : [],
            BattleTime: isSet(object.BattleTime) ? globalThis.Number(object.BattleTime) : 0,
            LBPoint: isSet(object.LBPoint) ? globalThis.Number(object.LBPoint) : 0,
            IsSupport: isSet(object.IsSupport) ? globalThis.Boolean(object.IsSupport) : false,
            BattleType: isSet(object.BattleType) ? globalThis.Number(object.BattleType) : 0,
            Operation: isSet(object.Operation)
                ? TArchiveCopyOperation.fromJSON(object.Operation)
                : undefined,
            FleetInfo: globalThis.Array.isArray(object?.FleetInfo)
                ? object.FleetInfo.map((e: any) => TPassFleetInfo.fromJSON(e))
                : [],
            HerosInfo: globalThis.Array.isArray(object?.HerosInfo)
                ? object.HerosInfo.map((e: any) => TBaseHeroInfo.fromJSON(e))
                : [],
            IsFinishMission: isSet(object.IsFinishMission)
                ? globalThis.Boolean(object.IsFinishMission)
                : false,
            EnemyFleets: globalThis.Array.isArray(object?.EnemyFleets)
                ? object.EnemyFleets.map((e: any) => TBattleEnemyFleet.fromJSON(e))
                : []
        }
    },

    toJSON(message: TPassBaseArg): unknown {
        const obj: any = {}
        if (message.BaseId !== undefined && message.BaseId !== 0) {
            obj.BaseId = Math.round(message.BaseId)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            obj.Rid = Math.round(message.Rid)
        }
        if (message.CacheId !== undefined && message.CacheId !== '') {
            obj.CacheId = message.CacheId
        }
        if (message.RunningTime !== undefined && message.RunningTime !== 0) {
            obj.RunningTime = Math.round(message.RunningTime)
        }
        if (message.MaxTimeScale !== undefined && message.MaxTimeScale !== 0) {
            obj.MaxTimeScale = message.MaxTimeScale
        }
        if (message.IsFlyAttack !== undefined && message.IsFlyAttack !== false) {
            obj.IsFlyAttack = message.IsFlyAttack
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            obj.IsRunningFight = message.IsRunningFight
        }
        if (message.Grade !== undefined && message.Grade !== 0) {
            obj.Grade = Math.round(message.Grade)
        }
        if (message.MvpHeroId !== undefined && message.MvpHeroId !== 0) {
            obj.MvpHeroId = Math.round(message.MvpHeroId)
        }
        if (message.BattleString !== undefined && message.BattleString !== '') {
            obj.BattleString = message.BattleString
        }
        if (message.Evaluate?.length) {
            obj.Evaluate = message.Evaluate.map((e) => TPassEvaluate.toJSON(e))
        }
        if (message.BattleTime !== undefined && message.BattleTime !== 0) {
            obj.BattleTime = Math.round(message.BattleTime)
        }
        if (message.LBPoint !== undefined && message.LBPoint !== 0) {
            obj.LBPoint = Math.round(message.LBPoint)
        }
        if (message.IsSupport !== undefined && message.IsSupport !== false) {
            obj.IsSupport = message.IsSupport
        }
        if (message.BattleType !== undefined && message.BattleType !== 0) {
            obj.BattleType = Math.round(message.BattleType)
        }
        if (message.Operation !== undefined) {
            obj.Operation = TArchiveCopyOperation.toJSON(message.Operation)
        }
        if (message.FleetInfo?.length) {
            obj.FleetInfo = message.FleetInfo.map((e) => TPassFleetInfo.toJSON(e))
        }
        if (message.HerosInfo?.length) {
            obj.HerosInfo = message.HerosInfo.map((e) => TBaseHeroInfo.toJSON(e))
        }
        if (message.IsFinishMission !== undefined && message.IsFinishMission !== false) {
            obj.IsFinishMission = message.IsFinishMission
        }
        if (message.EnemyFleets?.length) {
            obj.EnemyFleets = message.EnemyFleets.map((e) => TBattleEnemyFleet.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TPassBaseArg>, I>>(base?: I): TPassBaseArg {
        return TPassBaseArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TPassBaseArg>, I>>(object: I): TPassBaseArg {
        const message = createBaseTPassBaseArg()
        message.BaseId = object.BaseId ?? 0
        message.Rid = object.Rid ?? 0
        message.CacheId = object.CacheId ?? ''
        message.RunningTime = object.RunningTime ?? 0
        message.MaxTimeScale = object.MaxTimeScale ?? 0
        message.IsFlyAttack = object.IsFlyAttack ?? false
        message.IsRunningFight = object.IsRunningFight ?? false
        message.Grade = object.Grade ?? 0
        message.MvpHeroId = object.MvpHeroId ?? 0
        message.BattleString = object.BattleString ?? ''
        message.Evaluate = object.Evaluate?.map((e) => TPassEvaluate.fromPartial(e)) || []
        message.BattleTime = object.BattleTime ?? 0
        message.LBPoint = object.LBPoint ?? 0
        message.IsSupport = object.IsSupport ?? false
        message.BattleType = object.BattleType ?? 0
        message.Operation = (object.Operation !== undefined && object.Operation !== null)
            ? TArchiveCopyOperation.fromPartial(object.Operation)
            : undefined
        message.FleetInfo = object.FleetInfo?.map((e) => TPassFleetInfo.fromPartial(e)) || []
        message.HerosInfo = object.HerosInfo?.map((e) => TBaseHeroInfo.fromPartial(e)) || []
        message.IsFinishMission = object.IsFinishMission ?? false
        message.EnemyFleets = object.EnemyFleets?.map((e) => TBattleEnemyFleet.fromPartial(e)) ||
            []
        return message
    }
}

function createBaseTPassBaseRet(): TPassBaseRet {
    return {
        Reward: [],
        BattlePlayer: undefined,
        Ret: 0,
        Grade: 0,
        ExReward: [],
        StarLv: 0,
        Evaluate: [],
        PassTime: 0,
        ExtraReward: [],
        FirstPass: 0,
        ExpReward: [],
        CopyId: 0,
        BuildShipId: 0,
        BuildShipReward: [],
        MissionReward: []
    }
}

export const TPassBaseRet: MessageFns<TPassBaseRet> = {
    encode(message: TPassBaseRet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.Reward) {
            TCommonReward.encode(v!, writer.uint32(10).fork()).join()
        }
        if (message.BattlePlayer !== undefined) {
            TBattlePlayer.encode(message.BattlePlayer, writer.uint32(18).fork()).join()
        }
        if (message.Ret !== undefined && message.Ret !== 0) {
            writer.uint32(24).int32(message.Ret)
        }
        if (message.Grade !== undefined && message.Grade !== 0) {
            writer.uint32(32).int32(message.Grade)
        }
        for (const v of message.ExReward) {
            TCommonReward.encode(v!, writer.uint32(42).fork()).join()
        }
        if (message.StarLv !== undefined && message.StarLv !== 0) {
            writer.uint32(48).int32(message.StarLv)
        }
        for (const v of message.Evaluate) {
            TPassEvaluate.encode(v!, writer.uint32(58).fork()).join()
        }
        if (message.PassTime !== undefined && message.PassTime !== 0) {
            writer.uint32(64).int32(message.PassTime)
        }
        for (const v of message.ExtraReward) {
            TCommonExtraReward.encode(v!, writer.uint32(74).fork()).join()
        }
        if (message.FirstPass !== undefined && message.FirstPass !== 0) {
            writer.uint32(80).int32(message.FirstPass)
        }
        for (const v of message.ExpReward) {
            TCommonExpReward.encode(v!, writer.uint32(90).fork()).join()
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(96).int32(message.CopyId)
        }
        if (message.BuildShipId !== undefined && message.BuildShipId !== 0) {
            writer.uint32(104).int32(message.BuildShipId)
        }
        for (const v of message.BuildShipReward) {
            TCommonReward.encode(v!, writer.uint32(114).fork()).join()
        }
        for (const v of message.MissionReward) {
            TCommonReward.encode(v!, writer.uint32(122).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TPassBaseRet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTPassBaseRet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.Reward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.BattlePlayer = TBattlePlayer.decode(reader, reader.uint32())
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.Ret = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.Grade = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.ExReward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.StarLv = reader.int32()
                    continue
                }
                case 7: {
                    if (tag !== 58) {
                        break
                    }

                    message.Evaluate.push(TPassEvaluate.decode(reader, reader.uint32()))
                    continue
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.PassTime = reader.int32()
                    continue
                }
                case 9: {
                    if (tag !== 74) {
                        break
                    }

                    message.ExtraReward.push(TCommonExtraReward.decode(reader, reader.uint32()))
                    continue
                }
                case 10: {
                    if (tag !== 80) {
                        break
                    }

                    message.FirstPass = reader.int32()
                    continue
                }
                case 11: {
                    if (tag !== 90) {
                        break
                    }

                    message.ExpReward.push(TCommonExpReward.decode(reader, reader.uint32()))
                    continue
                }
                case 12: {
                    if (tag !== 96) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 13: {
                    if (tag !== 104) {
                        break
                    }

                    message.BuildShipId = reader.int32()
                    continue
                }
                case 14: {
                    if (tag !== 114) {
                        break
                    }

                    message.BuildShipReward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
                case 15: {
                    if (tag !== 122) {
                        break
                    }

                    message.MissionReward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TPassBaseRet {
        return {
            Reward: globalThis.Array.isArray(object?.Reward)
                ? object.Reward.map((e: any) => TCommonReward.fromJSON(e))
                : [],
            BattlePlayer: isSet(object.BattlePlayer)
                ? TBattlePlayer.fromJSON(object.BattlePlayer)
                : undefined,
            Ret: isSet(object.Ret) ? globalThis.Number(object.Ret) : 0,
            Grade: isSet(object.Grade) ? globalThis.Number(object.Grade) : 0,
            ExReward: globalThis.Array.isArray(object?.ExReward)
                ? object.ExReward.map((e: any) => TCommonReward.fromJSON(e))
                : [],
            StarLv: isSet(object.StarLv) ? globalThis.Number(object.StarLv) : 0,
            Evaluate: globalThis.Array.isArray(object?.Evaluate)
                ? object.Evaluate.map((e: any) => TPassEvaluate.fromJSON(e))
                : [],
            PassTime: isSet(object.PassTime) ? globalThis.Number(object.PassTime) : 0,
            ExtraReward: globalThis.Array.isArray(object?.ExtraReward)
                ? object.ExtraReward.map((e: any) => TCommonExtraReward.fromJSON(e))
                : [],
            FirstPass: isSet(object.FirstPass) ? globalThis.Number(object.FirstPass) : 0,
            ExpReward: globalThis.Array.isArray(object?.ExpReward)
                ? object.ExpReward.map((e: any) => TCommonExpReward.fromJSON(e))
                : [],
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            BuildShipId: isSet(object.BuildShipId) ? globalThis.Number(object.BuildShipId) : 0,
            BuildShipReward: globalThis.Array.isArray(object?.BuildShipReward)
                ? object.BuildShipReward.map((e: any) => TCommonReward.fromJSON(e))
                : [],
            MissionReward: globalThis.Array.isArray(object?.MissionReward)
                ? object.MissionReward.map((e: any) => TCommonReward.fromJSON(e))
                : []
        }
    },

    toJSON(message: TPassBaseRet): unknown {
        const obj: any = {}
        if (message.Reward?.length) {
            obj.Reward = message.Reward.map((e) => TCommonReward.toJSON(e))
        }
        if (message.BattlePlayer !== undefined) {
            obj.BattlePlayer = TBattlePlayer.toJSON(message.BattlePlayer)
        }
        if (message.Ret !== undefined && message.Ret !== 0) {
            obj.Ret = Math.round(message.Ret)
        }
        if (message.Grade !== undefined && message.Grade !== 0) {
            obj.Grade = Math.round(message.Grade)
        }
        if (message.ExReward?.length) {
            obj.ExReward = message.ExReward.map((e) => TCommonReward.toJSON(e))
        }
        if (message.StarLv !== undefined && message.StarLv !== 0) {
            obj.StarLv = Math.round(message.StarLv)
        }
        if (message.Evaluate?.length) {
            obj.Evaluate = message.Evaluate.map((e) => TPassEvaluate.toJSON(e))
        }
        if (message.PassTime !== undefined && message.PassTime !== 0) {
            obj.PassTime = Math.round(message.PassTime)
        }
        if (message.ExtraReward?.length) {
            obj.ExtraReward = message.ExtraReward.map((e) => TCommonExtraReward.toJSON(e))
        }
        if (message.FirstPass !== undefined && message.FirstPass !== 0) {
            obj.FirstPass = Math.round(message.FirstPass)
        }
        if (message.ExpReward?.length) {
            obj.ExpReward = message.ExpReward.map((e) => TCommonExpReward.toJSON(e))
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.BuildShipId !== undefined && message.BuildShipId !== 0) {
            obj.BuildShipId = Math.round(message.BuildShipId)
        }
        if (message.BuildShipReward?.length) {
            obj.BuildShipReward = message.BuildShipReward.map((e) => TCommonReward.toJSON(e))
        }
        if (message.MissionReward?.length) {
            obj.MissionReward = message.MissionReward.map((e) => TCommonReward.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TPassBaseRet>, I>>(base?: I): TPassBaseRet {
        return TPassBaseRet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TPassBaseRet>, I>>(object: I): TPassBaseRet {
        const message = createBaseTPassBaseRet()
        message.Reward = object.Reward?.map((e) => TCommonReward.fromPartial(e)) || []
        message.BattlePlayer = (object.BattlePlayer !== undefined && object.BattlePlayer !== null)
            ? TBattlePlayer.fromPartial(object.BattlePlayer)
            : undefined
        message.Ret = object.Ret ?? 0
        message.Grade = object.Grade ?? 0
        message.ExReward = object.ExReward?.map((e) => TCommonReward.fromPartial(e)) || []
        message.StarLv = object.StarLv ?? 0
        message.Evaluate = object.Evaluate?.map((e) => TPassEvaluate.fromPartial(e)) || []
        message.PassTime = object.PassTime ?? 0
        message.ExtraReward = object.ExtraReward?.map((e) => TCommonExtraReward.fromPartial(e)) ||
            []
        message.FirstPass = object.FirstPass ?? 0
        message.ExpReward = object.ExpReward?.map((e) => TCommonExpReward.fromPartial(e)) || []
        message.CopyId = object.CopyId ?? 0
        message.BuildShipId = object.BuildShipId ?? 0
        message.BuildShipReward =
            object.BuildShipReward?.map((e) => TCommonReward.fromPartial(e)) || []
        message.MissionReward = object.MissionReward?.map((e) => TCommonReward.fromPartial(e)) ||
            []
        return message
    }
}

function createBaseTPassEvaluate(): TPassEvaluate {
    return { Type: 0, Value: 0 }
}

export const TPassEvaluate: MessageFns<TPassEvaluate> = {
    encode(message: TPassEvaluate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Type !== undefined && message.Type !== 0) {
            writer.uint32(8).int32(message.Type)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            writer.uint32(16).int32(message.Value)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TPassEvaluate {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTPassEvaluate()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Type = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Value = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TPassEvaluate {
        return {
            Type: isSet(object.Type) ? globalThis.Number(object.Type) : 0,
            Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0
        }
    },

    toJSON(message: TPassEvaluate): unknown {
        const obj: any = {}
        if (message.Type !== undefined && message.Type !== 0) {
            obj.Type = Math.round(message.Type)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            obj.Value = Math.round(message.Value)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TPassEvaluate>, I>>(base?: I): TPassEvaluate {
        return TPassEvaluate.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TPassEvaluate>, I>>(object: I): TPassEvaluate {
        const message = createBaseTPassEvaluate()
        message.Type = object.Type ?? 0
        message.Value = object.Value ?? 0
        return message
    }
}

function createBaseTPassFleetInfo(): TPassFleetInfo {
    return { EnemyId: 0, EnemyInfo: [] }
}

export const TPassFleetInfo: MessageFns<TPassFleetInfo> = {
    encode(message: TPassFleetInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.EnemyId !== undefined && message.EnemyId !== 0) {
            writer.uint32(8).int32(message.EnemyId)
        }
        for (const v of message.EnemyInfo) {
            TBaseHeroInfo.encode(v!, writer.uint32(18).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TPassFleetInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTPassFleetInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.EnemyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.EnemyInfo.push(TBaseHeroInfo.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TPassFleetInfo {
        return {
            EnemyId: isSet(object.EnemyId) ? globalThis.Number(object.EnemyId) : 0,
            EnemyInfo: globalThis.Array.isArray(object?.EnemyInfo)
                ? object.EnemyInfo.map((e: any) => TBaseHeroInfo.fromJSON(e))
                : []
        }
    },

    toJSON(message: TPassFleetInfo): unknown {
        const obj: any = {}
        if (message.EnemyId !== undefined && message.EnemyId !== 0) {
            obj.EnemyId = Math.round(message.EnemyId)
        }
        if (message.EnemyInfo?.length) {
            obj.EnemyInfo = message.EnemyInfo.map((e) => TBaseHeroInfo.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TPassFleetInfo>, I>>(base?: I): TPassFleetInfo {
        return TPassFleetInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TPassFleetInfo>, I>>(object: I): TPassFleetInfo {
        const message = createBaseTPassFleetInfo()
        message.EnemyId = object.EnemyId ?? 0
        message.EnemyInfo = object.EnemyInfo?.map((e) => TBaseHeroInfo.fromPartial(e)) || []
        return message
    }
}

function createBaseTPassKvInfo(): TPassKvInfo {
    return { Type: 0, Value: 0 }
}

export const TPassKvInfo: MessageFns<TPassKvInfo> = {
    encode(message: TPassKvInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Type !== undefined && message.Type !== 0) {
            writer.uint32(8).int32(message.Type)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            writer.uint32(16).int32(message.Value)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TPassKvInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTPassKvInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Type = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Value = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TPassKvInfo {
        return {
            Type: isSet(object.Type) ? globalThis.Number(object.Type) : 0,
            Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0
        }
    },

    toJSON(message: TPassKvInfo): unknown {
        const obj: any = {}
        if (message.Type !== undefined && message.Type !== 0) {
            obj.Type = Math.round(message.Type)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            obj.Value = Math.round(message.Value)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TPassKvInfo>, I>>(base?: I): TPassKvInfo {
        return TPassKvInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TPassKvInfo>, I>>(object: I): TPassKvInfo {
        const message = createBaseTPassKvInfo()
        message.Type = object.Type ?? 0
        message.Value = object.Value ?? 0
        return message
    }
}

function createBaseTQuitBaseArg(): TQuitBaseArg {
    return {
        CopyId: 0,
        IsRunningFight: false,
        IsPass: false,
        HeroInfo: [],
        VerifyPackage: undefined,
        BattleMode: 0
    }
}

export const TQuitBaseArg: MessageFns<TQuitBaseArg> = {
    encode(message: TQuitBaseArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            writer.uint32(16).bool(message.IsRunningFight)
        }
        if (message.IsPass !== undefined && message.IsPass !== false) {
            writer.uint32(24).bool(message.IsPass)
        }
        for (const v of message.HeroInfo) {
            TBaseHeroInfo.encode(v!, writer.uint32(34).fork()).join()
        }
        if (message.VerifyPackage !== undefined) {
            TVerifyPackage.encode(message.VerifyPackage, writer.uint32(42).fork()).join()
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            writer.uint32(48).int32(message.BattleMode)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TQuitBaseArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTQuitBaseArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.IsRunningFight = reader.bool()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.IsPass = reader.bool()
                    continue
                }
                case 4: {
                    if (tag !== 34) {
                        break
                    }

                    message.HeroInfo.push(TBaseHeroInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.VerifyPackage = TVerifyPackage.decode(reader, reader.uint32())
                    continue
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.BattleMode = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TQuitBaseArg {
        return {
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            IsRunningFight: isSet(object.IsRunningFight)
                ? globalThis.Boolean(object.IsRunningFight)
                : false,
            IsPass: isSet(object.IsPass) ? globalThis.Boolean(object.IsPass) : false,
            HeroInfo: globalThis.Array.isArray(object?.HeroInfo)
                ? object.HeroInfo.map((e: any) => TBaseHeroInfo.fromJSON(e))
                : [],
            VerifyPackage: isSet(object.VerifyPackage)
                ? TVerifyPackage.fromJSON(object.VerifyPackage)
                : undefined,
            BattleMode: isSet(object.BattleMode) ? globalThis.Number(object.BattleMode) : 0
        }
    },

    toJSON(message: TQuitBaseArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            obj.IsRunningFight = message.IsRunningFight
        }
        if (message.IsPass !== undefined && message.IsPass !== false) {
            obj.IsPass = message.IsPass
        }
        if (message.HeroInfo?.length) {
            obj.HeroInfo = message.HeroInfo.map((e) => TBaseHeroInfo.toJSON(e))
        }
        if (message.VerifyPackage !== undefined) {
            obj.VerifyPackage = TVerifyPackage.toJSON(message.VerifyPackage)
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            obj.BattleMode = Math.round(message.BattleMode)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TQuitBaseArg>, I>>(base?: I): TQuitBaseArg {
        return TQuitBaseArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TQuitBaseArg>, I>>(object: I): TQuitBaseArg {
        const message = createBaseTQuitBaseArg()
        message.CopyId = object.CopyId ?? 0
        message.IsRunningFight = object.IsRunningFight ?? false
        message.IsPass = object.IsPass ?? false
        message.HeroInfo = object.HeroInfo?.map((e) => TBaseHeroInfo.fromPartial(e)) || []
        message.VerifyPackage =
            (object.VerifyPackage !== undefined && object.VerifyPackage !== null)
                ? TVerifyPackage.fromPartial(object.VerifyPackage)
                : undefined
        message.BattleMode = object.BattleMode ?? 0
        return message
    }
}

function createBaseTResRewardArg(): TResRewardArg {
    return { CopyId: 0, ResId: 0 }
}

export const TResRewardArg: MessageFns<TResRewardArg> = {
    encode(message: TResRewardArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        if (message.ResId !== undefined && message.ResId !== 0) {
            writer.uint32(16).int32(message.ResId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TResRewardArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTResRewardArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.ResId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TResRewardArg {
        return {
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            ResId: isSet(object.ResId) ? globalThis.Number(object.ResId) : 0
        }
    },

    toJSON(message: TResRewardArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.ResId !== undefined && message.ResId !== 0) {
            obj.ResId = Math.round(message.ResId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TResRewardArg>, I>>(base?: I): TResRewardArg {
        return TResRewardArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TResRewardArg>, I>>(object: I): TResRewardArg {
        const message = createBaseTResRewardArg()
        message.CopyId = object.CopyId ?? 0
        message.ResId = object.ResId ?? 0
        return message
    }
}

function createBaseTSfInfo(): TSfInfo {
    return { Type: 0, Info: [] }
}

export const TSfInfo: MessageFns<TSfInfo> = {
    encode(message: TSfInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Type !== undefined && message.Type !== 0) {
            writer.uint32(8).int32(message.Type)
        }
        for (const v of message.Info) {
            TSfStat.encode(v!, writer.uint32(18).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TSfInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTSfInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Type = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 18) {
                        break
                    }

                    message.Info.push(TSfStat.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TSfInfo {
        return {
            Type: isSet(object.Type) ? globalThis.Number(object.Type) : 0,
            Info: globalThis.Array.isArray(object?.Info)
                ? object.Info.map((e: any) => TSfStat.fromJSON(e))
                : []
        }
    },

    toJSON(message: TSfInfo): unknown {
        const obj: any = {}
        if (message.Type !== undefined && message.Type !== 0) {
            obj.Type = Math.round(message.Type)
        }
        if (message.Info?.length) {
            obj.Info = message.Info.map((e) => TSfStat.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TSfInfo>, I>>(base?: I): TSfInfo {
        return TSfInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TSfInfo>, I>>(object: I): TSfInfo {
        const message = createBaseTSfInfo()
        message.Type = object.Type ?? 0
        message.Info = object.Info?.map((e) => TSfStat.fromPartial(e)) || []
        return message
    }
}

function createBaseTSfStat(): TSfStat {
    return { Key: 0, Value: 0 }
}

export const TSfStat: MessageFns<TSfStat> = {
    encode(message: TSfStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Key !== undefined && message.Key !== 0) {
            writer.uint32(8).int32(message.Key)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            writer.uint32(16).int32(message.Value)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TSfStat {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTSfStat()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Key = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Value = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TSfStat {
        return {
            Key: isSet(object.Key) ? globalThis.Number(object.Key) : 0,
            Value: isSet(object.Value) ? globalThis.Number(object.Value) : 0
        }
    },

    toJSON(message: TSfStat): unknown {
        const obj: any = {}
        if (message.Key !== undefined && message.Key !== 0) {
            obj.Key = Math.round(message.Key)
        }
        if (message.Value !== undefined && message.Value !== 0) {
            obj.Value = Math.round(message.Value)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TSfStat>, I>>(base?: I): TSfStat {
        return TSfStat.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TSfStat>, I>>(object: I): TSfStat {
        const message = createBaseTSfStat()
        message.Key = object.Key ?? 0
        message.Value = object.Value ?? 0
        return message
    }
}

function createBaseTShipEquipGridInfo(): TShipEquipGridInfo {
    return { HeroId: 0, EquipGridNum: 0 }
}

export const TShipEquipGridInfo: MessageFns<TShipEquipGridInfo> = {
    encode(message: TShipEquipGridInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            writer.uint32(8).uint32(message.HeroId)
        }
        if (message.EquipGridNum !== undefined && message.EquipGridNum !== 0) {
            writer.uint32(16).int32(message.EquipGridNum)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TShipEquipGridInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTShipEquipGridInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.HeroId = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.EquipGridNum = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TShipEquipGridInfo {
        return {
            HeroId: isSet(object.HeroId) ? globalThis.Number(object.HeroId) : 0,
            EquipGridNum: isSet(object.EquipGridNum) ? globalThis.Number(object.EquipGridNum) : 0
        }
    },

    toJSON(message: TShipEquipGridInfo): unknown {
        const obj: any = {}
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            obj.HeroId = Math.round(message.HeroId)
        }
        if (message.EquipGridNum !== undefined && message.EquipGridNum !== 0) {
            obj.EquipGridNum = Math.round(message.EquipGridNum)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TShipEquipGridInfo>, I>>(base?: I): TShipEquipGridInfo {
        return TShipEquipGridInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TShipEquipGridInfo>, I>>(
        object: I
    ): TShipEquipGridInfo {
        const message = createBaseTShipEquipGridInfo()
        message.HeroId = object.HeroId ?? 0
        message.EquipGridNum = object.EquipGridNum ?? 0
        return message
    }
}

function createBaseTStarInfo(): TStarInfo {
    return { ChapterId: 0, StarNum: 0, StarReward: [], PassNum: 0, Rank: 0, StarRewardBox: [] }
}

export const TStarInfo: MessageFns<TStarInfo> = {
    encode(message: TStarInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            writer.uint32(8).int32(message.ChapterId)
        }
        if (message.StarNum !== undefined && message.StarNum !== 0) {
            writer.uint32(16).int32(message.StarNum)
        }
        for (const v of message.StarReward) {
            TStarReward.encode(v!, writer.uint32(26).fork()).join()
        }
        if (message.PassNum !== undefined && message.PassNum !== 0) {
            writer.uint32(32).int32(message.PassNum)
        }
        if (message.Rank !== undefined && message.Rank !== 0) {
            writer.uint32(40).int32(message.Rank)
        }
        for (const v of message.StarRewardBox) {
            TStarReward.encode(v!, writer.uint32(50).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStarInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStarInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.ChapterId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.StarNum = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 26) {
                        break
                    }

                    message.StarReward.push(TStarReward.decode(reader, reader.uint32()))
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.PassNum = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 40) {
                        break
                    }

                    message.Rank = reader.int32()
                    continue
                }
                case 6: {
                    if (tag !== 50) {
                        break
                    }

                    message.StarRewardBox.push(TStarReward.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStarInfo {
        return {
            ChapterId: isSet(object.ChapterId) ? globalThis.Number(object.ChapterId) : 0,
            StarNum: isSet(object.StarNum) ? globalThis.Number(object.StarNum) : 0,
            StarReward: globalThis.Array.isArray(object?.StarReward)
                ? object.StarReward.map((e: any) => TStarReward.fromJSON(e))
                : [],
            PassNum: isSet(object.PassNum) ? globalThis.Number(object.PassNum) : 0,
            Rank: isSet(object.Rank) ? globalThis.Number(object.Rank) : 0,
            StarRewardBox: globalThis.Array.isArray(object?.StarRewardBox)
                ? object.StarRewardBox.map((e: any) => TStarReward.fromJSON(e))
                : []
        }
    },

    toJSON(message: TStarInfo): unknown {
        const obj: any = {}
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            obj.ChapterId = Math.round(message.ChapterId)
        }
        if (message.StarNum !== undefined && message.StarNum !== 0) {
            obj.StarNum = Math.round(message.StarNum)
        }
        if (message.StarReward?.length) {
            obj.StarReward = message.StarReward.map((e) => TStarReward.toJSON(e))
        }
        if (message.PassNum !== undefined && message.PassNum !== 0) {
            obj.PassNum = Math.round(message.PassNum)
        }
        if (message.Rank !== undefined && message.Rank !== 0) {
            obj.Rank = Math.round(message.Rank)
        }
        if (message.StarRewardBox?.length) {
            obj.StarRewardBox = message.StarRewardBox.map((e) => TStarReward.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStarInfo>, I>>(base?: I): TStarInfo {
        return TStarInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStarInfo>, I>>(object: I): TStarInfo {
        const message = createBaseTStarInfo()
        message.ChapterId = object.ChapterId ?? 0
        message.StarNum = object.StarNum ?? 0
        message.StarReward = object.StarReward?.map((e) => TStarReward.fromPartial(e)) || []
        message.PassNum = object.PassNum ?? 0
        message.Rank = object.Rank ?? 0
        message.StarRewardBox = object.StarRewardBox?.map((e) => TStarReward.fromPartial(e)) || []
        return message
    }
}

function createBaseTStarReward(): TStarReward {
    return { Index: 0, RewardTime: 0 }
}

export const TStarReward: MessageFns<TStarReward> = {
    encode(message: TStarReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(8).int32(message.Index)
        }
        if (message.RewardTime !== undefined && message.RewardTime !== 0) {
            writer.uint32(16).int32(message.RewardTime)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStarReward {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStarReward()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.RewardTime = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStarReward {
        return {
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            RewardTime: isSet(object.RewardTime) ? globalThis.Number(object.RewardTime) : 0
        }
    },

    toJSON(message: TStarReward): unknown {
        const obj: any = {}
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.RewardTime !== undefined && message.RewardTime !== 0) {
            obj.RewardTime = Math.round(message.RewardTime)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStarReward>, I>>(base?: I): TStarReward {
        return TStarReward.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStarReward>, I>>(object: I): TStarReward {
        const message = createBaseTStarReward()
        message.Index = object.Index ?? 0
        message.RewardTime = object.RewardTime ?? 0
        return message
    }
}

function createBaseTStarRewardArg(): TStarRewardArg {
    return { ChapterId: 0, Index: 0, IndexList: [] }
}

export const TStarRewardArg: MessageFns<TStarRewardArg> = {
    encode(message: TStarRewardArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            writer.uint32(8).int32(message.ChapterId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(16).int32(message.Index)
        }
        for (const v of message.IndexList) {
            writer.uint32(24).int32(v!)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStarRewardArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStarRewardArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.ChapterId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 3: {
                    if (tag === 24) {
                        message.IndexList.push(reader.int32())

                        continue
                    }

                    if (tag === 26) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.IndexList.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStarRewardArg {
        return {
            ChapterId: isSet(object.ChapterId) ? globalThis.Number(object.ChapterId) : 0,
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            IndexList: globalThis.Array.isArray(object?.IndexList)
                ? object.IndexList.map((e: any) => globalThis.Number(e))
                : []
        }
    },

    toJSON(message: TStarRewardArg): unknown {
        const obj: any = {}
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            obj.ChapterId = Math.round(message.ChapterId)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.IndexList?.length) {
            obj.IndexList = message.IndexList.map((e) => Math.round(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStarRewardArg>, I>>(base?: I): TStarRewardArg {
        return TStarRewardArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStarRewardArg>, I>>(object: I): TStarRewardArg {
        const message = createBaseTStarRewardArg()
        message.ChapterId = object.ChapterId ?? 0
        message.Index = object.Index ?? 0
        message.IndexList = object.IndexList?.map((e) => e) || []
        return message
    }
}

function createBaseTStarRewardRet(): TStarRewardRet {
    return { Reward: [] }
}

export const TStarRewardRet: MessageFns<TStarRewardRet> = {
    encode(message: TStarRewardRet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.Reward) {
            TCommonReward.encode(v!, writer.uint32(10).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStarRewardRet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStarRewardRet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.Reward.push(TCommonReward.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStarRewardRet {
        return {
            Reward: globalThis.Array.isArray(object?.Reward)
                ? object.Reward.map((e: any) => TCommonReward.fromJSON(e))
                : []
        }
    },

    toJSON(message: TStarRewardRet): unknown {
        const obj: any = {}
        if (message.Reward?.length) {
            obj.Reward = message.Reward.map((e) => TCommonReward.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStarRewardRet>, I>>(base?: I): TStarRewardRet {
        return TStarRewardRet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStarRewardRet>, I>>(object: I): TStarRewardRet {
        const message = createBaseTStarRewardRet()
        message.Reward = object.Reward?.map((e) => TCommonReward.fromPartial(e)) || []
        return message
    }
}

function createBaseTStartBaseArg(): TStartBaseArg {
    return {
        ChapterId: 0,
        CopyId: 0,
        IsRunningFight: false,
        TacticId: 0,
        CacheId: '',
        DailyGroupId: 0,
        BattleMode: 0,
        AnimMode: 0,
        Power: 0,
        ExBuff: [],
        HeroList: [],
        RoomId: 0,
        MatchType: 0
    }
}

export const TStartBaseArg: MessageFns<TStartBaseArg> = {
    encode(message: TStartBaseArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            writer.uint32(8).int32(message.ChapterId)
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(16).int32(message.CopyId)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            writer.uint32(24).bool(message.IsRunningFight)
        }
        if (message.TacticId !== undefined && message.TacticId !== 0) {
            writer.uint32(32).int32(message.TacticId)
        }
        if (message.CacheId !== undefined && message.CacheId !== '') {
            writer.uint32(42).string(message.CacheId)
        }
        if (message.DailyGroupId !== undefined && message.DailyGroupId !== 0) {
            writer.uint32(64).int32(message.DailyGroupId)
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            writer.uint32(72).int32(message.BattleMode)
        }
        if (message.AnimMode !== undefined && message.AnimMode !== 0) {
            writer.uint32(80).int32(message.AnimMode)
        }
        if (message.Power !== undefined && message.Power !== 0) {
            writer.uint32(88).int32(message.Power)
        }
        for (const v of message.ExBuff) {
            writer.uint32(96).int32(v!)
        }
        for (const v of message.HeroList) {
            TStartBaseHeroList.encode(v!, writer.uint32(106).fork()).join()
        }
        if (message.RoomId !== undefined && message.RoomId !== 0) {
            writer.uint32(112).int32(message.RoomId)
        }
        if (message.MatchType !== undefined && message.MatchType !== 0) {
            writer.uint32(120).int32(message.MatchType)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStartBaseArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStartBaseArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.ChapterId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.IsRunningFight = reader.bool()
                    continue
                }
                case 4: {
                    if (tag !== 32) {
                        break
                    }

                    message.TacticId = reader.int32()
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.CacheId = reader.string()
                    continue
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.DailyGroupId = reader.int32()
                    continue
                }
                case 9: {
                    if (tag !== 72) {
                        break
                    }

                    message.BattleMode = reader.int32()
                    continue
                }
                case 10: {
                    if (tag !== 80) {
                        break
                    }

                    message.AnimMode = reader.int32()
                    continue
                }
                case 11: {
                    if (tag !== 88) {
                        break
                    }

                    message.Power = reader.int32()
                    continue
                }
                case 12: {
                    if (tag === 96) {
                        message.ExBuff.push(reader.int32())

                        continue
                    }

                    if (tag === 98) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.ExBuff.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 13: {
                    if (tag !== 106) {
                        break
                    }

                    message.HeroList.push(TStartBaseHeroList.decode(reader, reader.uint32()))
                    continue
                }
                case 14: {
                    if (tag !== 112) {
                        break
                    }

                    message.RoomId = reader.int32()
                    continue
                }
                case 15: {
                    if (tag !== 120) {
                        break
                    }

                    message.MatchType = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStartBaseArg {
        return {
            ChapterId: isSet(object.ChapterId) ? globalThis.Number(object.ChapterId) : 0,
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            IsRunningFight: isSet(object.IsRunningFight)
                ? globalThis.Boolean(object.IsRunningFight)
                : false,
            TacticId: isSet(object.TacticId) ? globalThis.Number(object.TacticId) : 0,
            CacheId: isSet(object.CacheId) ? globalThis.String(object.CacheId) : '',
            DailyGroupId: isSet(object.DailyGroupId) ? globalThis.Number(object.DailyGroupId) : 0,
            BattleMode: isSet(object.BattleMode) ? globalThis.Number(object.BattleMode) : 0,
            AnimMode: isSet(object.AnimMode) ? globalThis.Number(object.AnimMode) : 0,
            Power: isSet(object.Power) ? globalThis.Number(object.Power) : 0,
            ExBuff: globalThis.Array.isArray(object?.ExBuff)
                ? object.ExBuff.map((e: any) => globalThis.Number(e))
                : [],
            HeroList: globalThis.Array.isArray(object?.HeroList)
                ? object.HeroList.map((e: any) => TStartBaseHeroList.fromJSON(e))
                : [],
            RoomId: isSet(object.RoomId) ? globalThis.Number(object.RoomId) : 0,
            MatchType: isSet(object.MatchType) ? globalThis.Number(object.MatchType) : 0
        }
    },

    toJSON(message: TStartBaseArg): unknown {
        const obj: any = {}
        if (message.ChapterId !== undefined && message.ChapterId !== 0) {
            obj.ChapterId = Math.round(message.ChapterId)
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            obj.IsRunningFight = message.IsRunningFight
        }
        if (message.TacticId !== undefined && message.TacticId !== 0) {
            obj.TacticId = Math.round(message.TacticId)
        }
        if (message.CacheId !== undefined && message.CacheId !== '') {
            obj.CacheId = message.CacheId
        }
        if (message.DailyGroupId !== undefined && message.DailyGroupId !== 0) {
            obj.DailyGroupId = Math.round(message.DailyGroupId)
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            obj.BattleMode = Math.round(message.BattleMode)
        }
        if (message.AnimMode !== undefined && message.AnimMode !== 0) {
            obj.AnimMode = Math.round(message.AnimMode)
        }
        if (message.Power !== undefined && message.Power !== 0) {
            obj.Power = Math.round(message.Power)
        }
        if (message.ExBuff?.length) {
            obj.ExBuff = message.ExBuff.map((e) => Math.round(e))
        }
        if (message.HeroList?.length) {
            obj.HeroList = message.HeroList.map((e) => TStartBaseHeroList.toJSON(e))
        }
        if (message.RoomId !== undefined && message.RoomId !== 0) {
            obj.RoomId = Math.round(message.RoomId)
        }
        if (message.MatchType !== undefined && message.MatchType !== 0) {
            obj.MatchType = Math.round(message.MatchType)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStartBaseArg>, I>>(base?: I): TStartBaseArg {
        return TStartBaseArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStartBaseArg>, I>>(object: I): TStartBaseArg {
        const message = createBaseTStartBaseArg()
        message.ChapterId = object.ChapterId ?? 0
        message.CopyId = object.CopyId ?? 0
        message.IsRunningFight = object.IsRunningFight ?? false
        message.TacticId = object.TacticId ?? 0
        message.CacheId = object.CacheId ?? ''
        message.DailyGroupId = object.DailyGroupId ?? 0
        message.BattleMode = object.BattleMode ?? 0
        message.AnimMode = object.AnimMode ?? 0
        message.Power = object.Power ?? 0
        message.ExBuff = object.ExBuff?.map((e) => e) || []
        message.HeroList = object.HeroList?.map((e) => TStartBaseHeroList.fromPartial(e)) || []
        message.RoomId = object.RoomId ?? 0
        message.MatchType = object.MatchType ?? 0
        return message
    }
}

function createBaseTStartBaseHero(): TStartBaseHero {
    return { HeroId: 0, HeroTid: 0 }
}

export const TStartBaseHero: MessageFns<TStartBaseHero> = {
    encode(message: TStartBaseHero, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            writer.uint32(8).uint32(message.HeroId)
        }
        if (message.HeroTid !== undefined && message.HeroTid !== 0) {
            writer.uint32(16).int32(message.HeroTid)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStartBaseHero {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStartBaseHero()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.HeroId = reader.uint32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.HeroTid = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStartBaseHero {
        return {
            HeroId: isSet(object.HeroId) ? globalThis.Number(object.HeroId) : 0,
            HeroTid: isSet(object.HeroTid) ? globalThis.Number(object.HeroTid) : 0
        }
    },

    toJSON(message: TStartBaseHero): unknown {
        const obj: any = {}
        if (message.HeroId !== undefined && message.HeroId !== 0) {
            obj.HeroId = Math.round(message.HeroId)
        }
        if (message.HeroTid !== undefined && message.HeroTid !== 0) {
            obj.HeroTid = Math.round(message.HeroTid)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStartBaseHero>, I>>(base?: I): TStartBaseHero {
        return TStartBaseHero.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStartBaseHero>, I>>(object: I): TStartBaseHero {
        const message = createBaseTStartBaseHero()
        message.HeroId = object.HeroId ?? 0
        message.HeroTid = object.HeroTid ?? 0
        return message
    }
}

function createBaseTStartBaseHeroList(): TStartBaseHeroList {
    return { HeroIdList: [], Index: 0, StrategyId: 0 }
}

export const TStartBaseHeroList: MessageFns<TStartBaseHeroList> = {
    encode(message: TStartBaseHeroList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.HeroIdList) {
            writer.uint32(8).uint32(v!)
        }
        if (message.Index !== undefined && message.Index !== 0) {
            writer.uint32(16).int32(message.Index)
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            writer.uint32(24).int32(message.StrategyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStartBaseHeroList {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStartBaseHeroList()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.HeroIdList.push(reader.uint32())

                        continue
                    }

                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.HeroIdList.push(reader.uint32())
                        }

                        continue
                    }

                    break
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.Index = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.StrategyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStartBaseHeroList {
        return {
            HeroIdList: globalThis.Array.isArray(object?.HeroIdList)
                ? object.HeroIdList.map((e: any) => globalThis.Number(e))
                : [],
            Index: isSet(object.Index) ? globalThis.Number(object.Index) : 0,
            StrategyId: isSet(object.StrategyId) ? globalThis.Number(object.StrategyId) : 0
        }
    },

    toJSON(message: TStartBaseHeroList): unknown {
        const obj: any = {}
        if (message.HeroIdList?.length) {
            obj.HeroIdList = message.HeroIdList.map((e) => Math.round(e))
        }
        if (message.Index !== undefined && message.Index !== 0) {
            obj.Index = Math.round(message.Index)
        }
        if (message.StrategyId !== undefined && message.StrategyId !== 0) {
            obj.StrategyId = Math.round(message.StrategyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStartBaseHeroList>, I>>(base?: I): TStartBaseHeroList {
        return TStartBaseHeroList.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStartBaseHeroList>, I>>(
        object: I
    ): TStartBaseHeroList {
        const message = createBaseTStartBaseHeroList()
        message.HeroIdList = object.HeroIdList?.map((e) => e) || []
        message.Index = object.Index ?? 0
        message.StrategyId = object.StrategyId ?? 0
        return message
    }
}

function createBaseTStartBaseRet(): TStartBaseRet {
    return {
        BattlePlayer: undefined,
        RandomSeed: 0,
        Rid: 0,
        arrRes: [],
        EnemyFleet: [],
        CopyId: 0,
        CopyType: 0,
        CopyPass: false,
        BossProgress: 0,
        IsRunningFight: false,
        ShipEquipGridInfo: [],
        RandomFactors: [],
        SafeLv: 0,
        Verify: undefined,
        ExtraBattlePlayerList: [],
        Token: '',
        SkipVcr: [],
        BattleMode: 0,
        IsFinal: false,
        AnimMode: 0,
        WeatherGroupId: 0,
        CopyMission: [],
        EnemyFleets: [],
        ConfigData: [],
        MatchType: 0
    }
}

export const TStartBaseRet: MessageFns<TStartBaseRet> = {
    encode(message: TStartBaseRet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.BattlePlayer !== undefined) {
            TBattlePlayerList.encode(message.BattlePlayer, writer.uint32(10).fork()).join()
        }
        if (message.RandomSeed !== undefined && message.RandomSeed !== 0) {
            writer.uint32(16).int32(message.RandomSeed)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            writer.uint32(24).int32(message.Rid)
        }
        for (const v of message.arrRes) {
            TCopyRes.encode(v!, writer.uint32(34).fork()).join()
        }
        for (const v of message.EnemyFleet) {
            writer.uint32(40).int32(v!)
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(48).int32(message.CopyId)
        }
        if (message.CopyType !== undefined && message.CopyType !== 0) {
            writer.uint32(56).int32(message.CopyType)
        }
        if (message.CopyPass !== undefined && message.CopyPass !== false) {
            writer.uint32(64).bool(message.CopyPass)
        }
        if (message.BossProgress !== undefined && message.BossProgress !== 0) {
            writer.uint32(72).int32(message.BossProgress)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            writer.uint32(80).bool(message.IsRunningFight)
        }
        for (const v of message.ShipEquipGridInfo) {
            TShipEquipGridInfo.encode(v!, writer.uint32(90).fork()).join()
        }
        for (const v of message.RandomFactors) {
            TRandomFactor.encode(v!, writer.uint32(98).fork()).join()
        }
        if (message.SafeLv !== undefined && message.SafeLv !== 0) {
            writer.uint32(104).int32(message.SafeLv)
        }
        if (message.Verify !== undefined) {
            TVerifyPackage.encode(message.Verify, writer.uint32(114).fork()).join()
        }
        for (const v of message.ExtraBattlePlayerList) {
            TBattlePlayerList.encode(v!, writer.uint32(122).fork()).join()
        }
        if (message.Token !== undefined && message.Token !== '') {
            writer.uint32(130).string(message.Token)
        }
        for (const v of message.SkipVcr) {
            TCopySkipVcr.encode(v!, writer.uint32(138).fork()).join()
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            writer.uint32(144).int32(message.BattleMode)
        }
        if (message.IsFinal !== undefined && message.IsFinal !== false) {
            writer.uint32(152).bool(message.IsFinal)
        }
        if (message.AnimMode !== undefined && message.AnimMode !== 0) {
            writer.uint32(160).int32(message.AnimMode)
        }
        if (message.WeatherGroupId !== undefined && message.WeatherGroupId !== 0) {
            writer.uint32(176).int32(message.WeatherGroupId)
        }
        for (const v of message.CopyMission) {
            writer.uint32(184).int32(v!)
        }
        for (const v of message.EnemyFleets) {
            TBattleEnemyFleet.encode(v!, writer.uint32(194).fork()).join()
        }
        for (const v of message.ConfigData) {
            TPassEvaluate.encode(v!, writer.uint32(202).fork()).join()
        }
        if (message.MatchType !== undefined && message.MatchType !== 0) {
            writer.uint32(208).int32(message.MatchType)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TStartBaseRet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTStartBaseRet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.BattlePlayer = TBattlePlayerList.decode(reader, reader.uint32())
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.RandomSeed = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.Rid = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 34) {
                        break
                    }

                    message.arrRes.push(TCopyRes.decode(reader, reader.uint32()))
                    continue
                }
                case 5: {
                    if (tag === 40) {
                        message.EnemyFleet.push(reader.int32())

                        continue
                    }

                    if (tag === 42) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.EnemyFleet.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 6: {
                    if (tag !== 48) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
                case 7: {
                    if (tag !== 56) {
                        break
                    }

                    message.CopyType = reader.int32()
                    continue
                }
                case 8: {
                    if (tag !== 64) {
                        break
                    }

                    message.CopyPass = reader.bool()
                    continue
                }
                case 9: {
                    if (tag !== 72) {
                        break
                    }

                    message.BossProgress = reader.int32()
                    continue
                }
                case 10: {
                    if (tag !== 80) {
                        break
                    }

                    message.IsRunningFight = reader.bool()
                    continue
                }
                case 11: {
                    if (tag !== 90) {
                        break
                    }

                    message.ShipEquipGridInfo.push(
                        TShipEquipGridInfo.decode(reader, reader.uint32())
                    )
                    continue
                }
                case 12: {
                    if (tag !== 98) {
                        break
                    }

                    message.RandomFactors.push(TRandomFactor.decode(reader, reader.uint32()))
                    continue
                }
                case 13: {
                    if (tag !== 104) {
                        break
                    }

                    message.SafeLv = reader.int32()
                    continue
                }
                case 14: {
                    if (tag !== 114) {
                        break
                    }

                    message.Verify = TVerifyPackage.decode(reader, reader.uint32())
                    continue
                }
                case 15: {
                    if (tag !== 122) {
                        break
                    }

                    message.ExtraBattlePlayerList.push(
                        TBattlePlayerList.decode(reader, reader.uint32())
                    )
                    continue
                }
                case 16: {
                    if (tag !== 130) {
                        break
                    }

                    message.Token = reader.string()
                    continue
                }
                case 17: {
                    if (tag !== 138) {
                        break
                    }

                    message.SkipVcr.push(TCopySkipVcr.decode(reader, reader.uint32()))
                    continue
                }
                case 18: {
                    if (tag !== 144) {
                        break
                    }

                    message.BattleMode = reader.int32()
                    continue
                }
                case 19: {
                    if (tag !== 152) {
                        break
                    }

                    message.IsFinal = reader.bool()
                    continue
                }
                case 20: {
                    if (tag !== 160) {
                        break
                    }

                    message.AnimMode = reader.int32()
                    continue
                }
                case 22: {
                    if (tag !== 176) {
                        break
                    }

                    message.WeatherGroupId = reader.int32()
                    continue
                }
                case 23: {
                    if (tag === 184) {
                        message.CopyMission.push(reader.int32())

                        continue
                    }

                    if (tag === 186) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.CopyMission.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
                case 24: {
                    if (tag !== 194) {
                        break
                    }

                    message.EnemyFleets.push(TBattleEnemyFleet.decode(reader, reader.uint32()))
                    continue
                }
                case 25: {
                    if (tag !== 202) {
                        break
                    }

                    message.ConfigData.push(TPassEvaluate.decode(reader, reader.uint32()))
                    continue
                }
                case 26: {
                    if (tag !== 208) {
                        break
                    }

                    message.MatchType = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TStartBaseRet {
        return {
            BattlePlayer: isSet(object.BattlePlayer)
                ? TBattlePlayerList.fromJSON(object.BattlePlayer)
                : undefined,
            RandomSeed: isSet(object.RandomSeed) ? globalThis.Number(object.RandomSeed) : 0,
            Rid: isSet(object.Rid) ? globalThis.Number(object.Rid) : 0,
            arrRes: globalThis.Array.isArray(object?.arrRes)
                ? object.arrRes.map((e: any) => TCopyRes.fromJSON(e))
                : [],
            EnemyFleet: globalThis.Array.isArray(object?.EnemyFleet)
                ? object.EnemyFleet.map((e: any) => globalThis.Number(e))
                : [],
            CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0,
            CopyType: isSet(object.CopyType) ? globalThis.Number(object.CopyType) : 0,
            CopyPass: isSet(object.CopyPass) ? globalThis.Boolean(object.CopyPass) : false,
            BossProgress: isSet(object.BossProgress) ? globalThis.Number(object.BossProgress) : 0,
            IsRunningFight: isSet(object.IsRunningFight)
                ? globalThis.Boolean(object.IsRunningFight)
                : false,
            ShipEquipGridInfo: globalThis.Array.isArray(object?.ShipEquipGridInfo)
                ? object.ShipEquipGridInfo.map((e: any) => TShipEquipGridInfo.fromJSON(e))
                : [],
            RandomFactors: globalThis.Array.isArray(object?.RandomFactors)
                ? object.RandomFactors.map((e: any) => TRandomFactor.fromJSON(e))
                : [],
            SafeLv: isSet(object.SafeLv) ? globalThis.Number(object.SafeLv) : 0,
            Verify: isSet(object.Verify) ? TVerifyPackage.fromJSON(object.Verify) : undefined,
            ExtraBattlePlayerList: globalThis.Array.isArray(object?.ExtraBattlePlayerList)
                ? object.ExtraBattlePlayerList.map((e: any) => TBattlePlayerList.fromJSON(e))
                : [],
            Token: isSet(object.Token) ? globalThis.String(object.Token) : '',
            SkipVcr: globalThis.Array.isArray(object?.SkipVcr)
                ? object.SkipVcr.map((e: any) => TCopySkipVcr.fromJSON(e))
                : [],
            BattleMode: isSet(object.BattleMode) ? globalThis.Number(object.BattleMode) : 0,
            IsFinal: isSet(object.IsFinal) ? globalThis.Boolean(object.IsFinal) : false,
            AnimMode: isSet(object.AnimMode) ? globalThis.Number(object.AnimMode) : 0,
            WeatherGroupId: isSet(object.WeatherGroupId)
                ? globalThis.Number(object.WeatherGroupId)
                : 0,
            CopyMission: globalThis.Array.isArray(object?.CopyMission)
                ? object.CopyMission.map((e: any) => globalThis.Number(e))
                : [],
            EnemyFleets: globalThis.Array.isArray(object?.EnemyFleets)
                ? object.EnemyFleets.map((e: any) => TBattleEnemyFleet.fromJSON(e))
                : [],
            ConfigData: globalThis.Array.isArray(object?.ConfigData)
                ? object.ConfigData.map((e: any) => TPassEvaluate.fromJSON(e))
                : [],
            MatchType: isSet(object.MatchType) ? globalThis.Number(object.MatchType) : 0
        }
    },

    toJSON(message: TStartBaseRet): unknown {
        const obj: any = {}
        if (message.BattlePlayer !== undefined) {
            obj.BattlePlayer = TBattlePlayerList.toJSON(message.BattlePlayer)
        }
        if (message.RandomSeed !== undefined && message.RandomSeed !== 0) {
            obj.RandomSeed = Math.round(message.RandomSeed)
        }
        if (message.Rid !== undefined && message.Rid !== 0) {
            obj.Rid = Math.round(message.Rid)
        }
        if (message.arrRes?.length) {
            obj.arrRes = message.arrRes.map((e) => TCopyRes.toJSON(e))
        }
        if (message.EnemyFleet?.length) {
            obj.EnemyFleet = message.EnemyFleet.map((e) => Math.round(e))
        }
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        if (message.CopyType !== undefined && message.CopyType !== 0) {
            obj.CopyType = Math.round(message.CopyType)
        }
        if (message.CopyPass !== undefined && message.CopyPass !== false) {
            obj.CopyPass = message.CopyPass
        }
        if (message.BossProgress !== undefined && message.BossProgress !== 0) {
            obj.BossProgress = Math.round(message.BossProgress)
        }
        if (message.IsRunningFight !== undefined && message.IsRunningFight !== false) {
            obj.IsRunningFight = message.IsRunningFight
        }
        if (message.ShipEquipGridInfo?.length) {
            obj.ShipEquipGridInfo = message.ShipEquipGridInfo.map((e) =>
                TShipEquipGridInfo.toJSON(e)
            )
        }
        if (message.RandomFactors?.length) {
            obj.RandomFactors = message.RandomFactors.map((e) => TRandomFactor.toJSON(e))
        }
        if (message.SafeLv !== undefined && message.SafeLv !== 0) {
            obj.SafeLv = Math.round(message.SafeLv)
        }
        if (message.Verify !== undefined) {
            obj.Verify = TVerifyPackage.toJSON(message.Verify)
        }
        if (message.ExtraBattlePlayerList?.length) {
            obj.ExtraBattlePlayerList = message.ExtraBattlePlayerList.map((e) =>
                TBattlePlayerList.toJSON(e)
            )
        }
        if (message.Token !== undefined && message.Token !== '') {
            obj.Token = message.Token
        }
        if (message.SkipVcr?.length) {
            obj.SkipVcr = message.SkipVcr.map((e) => TCopySkipVcr.toJSON(e))
        }
        if (message.BattleMode !== undefined && message.BattleMode !== 0) {
            obj.BattleMode = Math.round(message.BattleMode)
        }
        if (message.IsFinal !== undefined && message.IsFinal !== false) {
            obj.IsFinal = message.IsFinal
        }
        if (message.AnimMode !== undefined && message.AnimMode !== 0) {
            obj.AnimMode = Math.round(message.AnimMode)
        }
        if (message.WeatherGroupId !== undefined && message.WeatherGroupId !== 0) {
            obj.WeatherGroupId = Math.round(message.WeatherGroupId)
        }
        if (message.CopyMission?.length) {
            obj.CopyMission = message.CopyMission.map((e) => Math.round(e))
        }
        if (message.EnemyFleets?.length) {
            obj.EnemyFleets = message.EnemyFleets.map((e) => TBattleEnemyFleet.toJSON(e))
        }
        if (message.ConfigData?.length) {
            obj.ConfigData = message.ConfigData.map((e) => TPassEvaluate.toJSON(e))
        }
        if (message.MatchType !== undefined && message.MatchType !== 0) {
            obj.MatchType = Math.round(message.MatchType)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TStartBaseRet>, I>>(base?: I): TStartBaseRet {
        return TStartBaseRet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TStartBaseRet>, I>>(object: I): TStartBaseRet {
        const message = createBaseTStartBaseRet()
        message.BattlePlayer = (object.BattlePlayer !== undefined && object.BattlePlayer !== null)
            ? TBattlePlayerList.fromPartial(object.BattlePlayer)
            : undefined
        message.RandomSeed = object.RandomSeed ?? 0
        message.Rid = object.Rid ?? 0
        message.arrRes = object.arrRes?.map((e) => TCopyRes.fromPartial(e)) || []
        message.EnemyFleet = object.EnemyFleet?.map((e) => e) || []
        message.CopyId = object.CopyId ?? 0
        message.CopyType = object.CopyType ?? 0
        message.CopyPass = object.CopyPass ?? false
        message.BossProgress = object.BossProgress ?? 0
        message.IsRunningFight = object.IsRunningFight ?? false
        message.ShipEquipGridInfo =
            object.ShipEquipGridInfo?.map((e) => TShipEquipGridInfo.fromPartial(e)) || []
        message.RandomFactors = object.RandomFactors?.map((e) => TRandomFactor.fromPartial(e)) ||
            []
        message.SafeLv = object.SafeLv ?? 0
        message.Verify = (object.Verify !== undefined && object.Verify !== null)
            ? TVerifyPackage.fromPartial(object.Verify)
            : undefined
        message.ExtraBattlePlayerList =
            object.ExtraBattlePlayerList?.map((e) => TBattlePlayerList.fromPartial(e)) || []
        message.Token = object.Token ?? ''
        message.SkipVcr = object.SkipVcr?.map((e) => TCopySkipVcr.fromPartial(e)) || []
        message.BattleMode = object.BattleMode ?? 0
        message.IsFinal = object.IsFinal ?? false
        message.AnimMode = object.AnimMode ?? 0
        message.WeatherGroupId = object.WeatherGroupId ?? 0
        message.CopyMission = object.CopyMission?.map((e) => e) || []
        message.EnemyFleets = object.EnemyFleets?.map((e) => TBattleEnemyFleet.fromPartial(e)) ||
            []
        message.ConfigData = object.ConfigData?.map((e) => TPassEvaluate.fromPartial(e)) || []
        message.MatchType = object.MatchType ?? 0
        return message
    }
}

function createBaseTTestPassArg(): TTestPassArg {
    return { StartCopyId: 0, EndCopyId: 0 }
}

export const TTestPassArg: MessageFns<TTestPassArg> = {
    encode(message: TTestPassArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.StartCopyId !== undefined && message.StartCopyId !== 0) {
            writer.uint32(8).int32(message.StartCopyId)
        }
        if (message.EndCopyId !== undefined && message.EndCopyId !== 0) {
            writer.uint32(16).int32(message.EndCopyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TTestPassArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTTestPassArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.StartCopyId = reader.int32()
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.EndCopyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TTestPassArg {
        return {
            StartCopyId: isSet(object.StartCopyId) ? globalThis.Number(object.StartCopyId) : 0,
            EndCopyId: isSet(object.EndCopyId) ? globalThis.Number(object.EndCopyId) : 0
        }
    },

    toJSON(message: TTestPassArg): unknown {
        const obj: any = {}
        if (message.StartCopyId !== undefined && message.StartCopyId !== 0) {
            obj.StartCopyId = Math.round(message.StartCopyId)
        }
        if (message.EndCopyId !== undefined && message.EndCopyId !== 0) {
            obj.EndCopyId = Math.round(message.EndCopyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TTestPassArg>, I>>(base?: I): TTestPassArg {
        return TTestPassArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TTestPassArg>, I>>(object: I): TTestPassArg {
        const message = createBaseTTestPassArg()
        message.StartCopyId = object.StartCopyId ?? 0
        message.EndCopyId = object.EndCopyId ?? 0
        return message
    }
}

function createBaseTTestPassRet(): TTestPassRet {
    return { CopyIdList: [] }
}

export const TTestPassRet: MessageFns<TTestPassRet> = {
    encode(message: TTestPassRet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.CopyIdList) {
            writer.uint32(8).int32(v!)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TTestPassRet {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTTestPassRet()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag === 8) {
                        message.CopyIdList.push(reader.int32())

                        continue
                    }

                    if (tag === 10) {
                        const end2 = reader.uint32() + reader.pos
                        while (reader.pos < end2) {
                            message.CopyIdList.push(reader.int32())
                        }

                        continue
                    }

                    break
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TTestPassRet {
        return {
            CopyIdList: globalThis.Array.isArray(object?.CopyIdList)
                ? object.CopyIdList.map((e: any) => globalThis.Number(e))
                : []
        }
    },

    toJSON(message: TTestPassRet): unknown {
        const obj: any = {}
        if (message.CopyIdList?.length) {
            obj.CopyIdList = message.CopyIdList.map((e) => Math.round(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TTestPassRet>, I>>(base?: I): TTestPassRet {
        return TTestPassRet.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TTestPassRet>, I>>(object: I): TTestPassRet {
        const message = createBaseTTestPassRet()
        message.CopyIdList = object.CopyIdList?.map((e) => e) || []
        return message
    }
}

function createBaseTUnlockedCopyArg(): TUnlockedCopyArg {
    return { CopyId: 0 }
}

export const TUnlockedCopyArg: MessageFns<TUnlockedCopyArg> = {
    encode(message: TUnlockedCopyArg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            writer.uint32(8).int32(message.CopyId)
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TUnlockedCopyArg {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTUnlockedCopyArg()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break
                    }

                    message.CopyId = reader.int32()
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TUnlockedCopyArg {
        return { CopyId: isSet(object.CopyId) ? globalThis.Number(object.CopyId) : 0 }
    },

    toJSON(message: TUnlockedCopyArg): unknown {
        const obj: any = {}
        if (message.CopyId !== undefined && message.CopyId !== 0) {
            obj.CopyId = Math.round(message.CopyId)
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TUnlockedCopyArg>, I>>(base?: I): TUnlockedCopyArg {
        return TUnlockedCopyArg.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TUnlockedCopyArg>, I>>(object: I): TUnlockedCopyArg {
        const message = createBaseTUnlockedCopyArg()
        message.CopyId = object.CopyId ?? 0
        return message
    }
}

function createBaseTUserCopyInfo(): TUserCopyInfo {
    return { BaseInfo: [], MaxCopyId: 0, CopyType: 0, StarInfo: [], PassCopyCount: [] }
}

export const TUserCopyInfo: MessageFns<TUserCopyInfo> = {
    encode(message: TUserCopyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        for (const v of message.BaseInfo) {
            TBaseInfo.encode(v!, writer.uint32(10).fork()).join()
        }
        if (message.MaxCopyId !== undefined && message.MaxCopyId !== 0) {
            writer.uint32(16).int32(message.MaxCopyId)
        }
        if (message.CopyType !== undefined && message.CopyType !== 0) {
            writer.uint32(24).int32(message.CopyType)
        }
        for (const v of message.StarInfo) {
            TStarInfo.encode(v!, writer.uint32(34).fork()).join()
        }
        for (const v of message.PassCopyCount) {
            TPassKvInfo.encode(v!, writer.uint32(42).fork()).join()
        }
        return writer
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TUserCopyInfo {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
        const end = length === undefined ? reader.len : reader.pos + length
        const message = createBaseTUserCopyInfo()
        while (reader.pos < end) {
            const tag = reader.uint32()
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break
                    }

                    message.BaseInfo.push(TBaseInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 2: {
                    if (tag !== 16) {
                        break
                    }

                    message.MaxCopyId = reader.int32()
                    continue
                }
                case 3: {
                    if (tag !== 24) {
                        break
                    }

                    message.CopyType = reader.int32()
                    continue
                }
                case 4: {
                    if (tag !== 34) {
                        break
                    }

                    message.StarInfo.push(TStarInfo.decode(reader, reader.uint32()))
                    continue
                }
                case 5: {
                    if (tag !== 42) {
                        break
                    }

                    message.PassCopyCount.push(TPassKvInfo.decode(reader, reader.uint32()))
                    continue
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break
            }
            reader.skip(tag & 7)
        }
        return message
    },

    fromJSON(object: any): TUserCopyInfo {
        return {
            BaseInfo: globalThis.Array.isArray(object?.BaseInfo)
                ? object.BaseInfo.map((e: any) => TBaseInfo.fromJSON(e))
                : [],
            MaxCopyId: isSet(object.MaxCopyId) ? globalThis.Number(object.MaxCopyId) : 0,
            CopyType: isSet(object.CopyType) ? globalThis.Number(object.CopyType) : 0,
            StarInfo: globalThis.Array.isArray(object?.StarInfo)
                ? object.StarInfo.map((e: any) => TStarInfo.fromJSON(e))
                : [],
            PassCopyCount: globalThis.Array.isArray(object?.PassCopyCount)
                ? object.PassCopyCount.map((e: any) => TPassKvInfo.fromJSON(e))
                : []
        }
    },

    toJSON(message: TUserCopyInfo): unknown {
        const obj: any = {}
        if (message.BaseInfo?.length) {
            obj.BaseInfo = message.BaseInfo.map((e) => TBaseInfo.toJSON(e))
        }
        if (message.MaxCopyId !== undefined && message.MaxCopyId !== 0) {
            obj.MaxCopyId = Math.round(message.MaxCopyId)
        }
        if (message.CopyType !== undefined && message.CopyType !== 0) {
            obj.CopyType = Math.round(message.CopyType)
        }
        if (message.StarInfo?.length) {
            obj.StarInfo = message.StarInfo.map((e) => TStarInfo.toJSON(e))
        }
        if (message.PassCopyCount?.length) {
            obj.PassCopyCount = message.PassCopyCount.map((e) => TPassKvInfo.toJSON(e))
        }
        return obj
    },

    create<I extends Exact<DeepPartial<TUserCopyInfo>, I>>(base?: I): TUserCopyInfo {
        return TUserCopyInfo.fromPartial(base ?? ({} as any))
    },
    fromPartial<I extends Exact<DeepPartial<TUserCopyInfo>, I>>(object: I): TUserCopyInfo {
        const message = createBaseTUserCopyInfo()
        message.BaseInfo = object.BaseInfo?.map((e) => TBaseInfo.fromPartial(e)) || []
        message.MaxCopyId = object.MaxCopyId ?? 0
        message.CopyType = object.CopyType ?? 0
        message.StarInfo = object.StarInfo?.map((e) => TStarInfo.fromPartial(e)) || []
        message.PassCopyCount = object.PassCopyCount?.map((e) => TPassKvInfo.fromPartial(e)) || []
        return message
    }
}

function bytesFromBase64(b64: string): Uint8Array {
    if ((globalThis as any).Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'))
    } else {
        const bin = globalThis.atob(b64)
        const arr = new Uint8Array(bin.length)
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i)
        }
        return arr
    }
}

function base64FromBytes(arr: Uint8Array): string {
    if ((globalThis as any).Buffer) {
        return globalThis.Buffer.from(arr).toString('base64')
    } else {
        const bin: string[] = []
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte))
        })
        return globalThis.btoa(bin.join(''))
    }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined

export type DeepPartial<T> = T extends Builtin ? T
    : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
    : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
    : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin ? P
    :
        & P
        & { [K in keyof P]: Exact<P[K], I[K]> }
        & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never }

function longToNumber(int64: { toString(): string }): number {
    const num = globalThis.Number(int64.toString())
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER')
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER')
    }
    return num
}

function isSet(value: any): boolean {
    return value !== null && value !== undefined
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter
    decode(input: BinaryReader | Uint8Array, length?: number): T
    fromJSON(object: any): T
    toJSON(message: T): unknown
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
